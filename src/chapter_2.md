# 第二章：计算机基础与Rust定位

对于一些小白来说，第一章我们操作的安装Rust的操作，其实是一知半解的。Rust是一个编程语言 or 软件 or 什么别的？ `cargo`又是什么东西。其实在学习编程的时候，很多人都是被这些底层的原理给吓跑了，因为在学校的时候，我们只是按照书本上的内容进行操作，进行配置环境，但是问到这是怎么运行的，就会说："我不道啊，都是老师教的。"这一章就是用来补齐一些计算机基础，从第一步开始就**稳扎稳打、注重内力**，这不仅对学习Rust有帮助，这是学习任何计算机相关的知识的基础。

## 2.0 计算机基础入门

### 2.0.1 计算机系统的基本组成

计算机系统主要由*硬件*和*软件*两大部分组成，二者密不可分：

- **硬件**：计算机的"躯壳"，包括CPU（中央处理器）、内存（RAM）、硬盘（存储）、输入输出设备（如键盘、鼠标、显示器等）。
- **软件**：计算机的"灵魂"，包括操作系统（如Windows、Linux、macOS）和各种应用程序（如微信、浏览器、游戏等）。软件通过一系列指令控制硬件完成各种任务。

#### 生活类比：
- 硬件就像汽车的发动机、轮胎、方向盘等零件，软件就像驾驶员的操作方法、导航系统、音乐播放等功能。没有硬件，软件"无处可跑"；没有软件，硬件"不会动"。
- 也可以用厨房来比喻：
    - **CPU** 就像厨师，负责思考和做菜（处理数据和指令）。
    - **内存** 就像操作台，厨师把正在做的菜和用到的食材都放在这里，方便随时拿取。
    - **硬盘** 就像储藏室，存放大量还没用到的食材和工具，需要时再拿出来。
    - **输入设备**（如键盘、鼠标）就像点菜的顾客或送菜的服务员，把需求和信息传递给厨师。
    - **输出设备**（如显示器、打印机）就像上菜窗口，把做好的菜端给顾客。
    - **软件** 就像菜谱和餐厅的规则，指导厨师和服务员如何协作。

整个厨房高效运作，离不开每个环节的协作，这就像计算机硬件和软件的分工一样。

#### 思考与解释：
- **为什么内存比硬盘小很多，但速度快很多？**
    - 操作台（内存）空间有限，但厨师可以非常快地拿取和处理。储藏室（硬盘）空间大，但每次取用都要走一趟，速度慢得多。
    - 内存技术快但贵，硬盘容量大但慢。
- **为什么不能把所有东西都放在内存？**
    - 操作台太大既贵又占地方，很多食材暂时用不到，放在储藏室更合适。
- **为什么程序运行时要"加载"到内存？**
    - 就像厨师做菜前要把食材从储藏室拿到操作台，程序运行前也要把数据和指令从硬盘搬到内存，CPU才能高效处理。

---

### 2.0.2 软件是如何运行的

计算机只能识别0和1（二进制），所有数据和指令最终都要转成0/1（二进制文件）。十六进制常用于表示内存地址和数据，便于阅读和调试。

#### 编程语言的翻译器：编译器和解释器

- **编译器**：一种特殊的软件工具（"翻译官"），能把我们写的"高级语言"代码（如C、Rust）一次性翻译成计算机能直接执行的"机器码"，生成可执行文件，运行速度快。
- **解释器**：像"翻译员"，每次运行时逐行翻译代码，边翻译边执行，灵活但速度慢（如Python、JavaScript）。

##### 生活化比喻：
- 编译器像把一本英文小说全部翻译成中文再出版，读者可以直接看中文版。
- 解释器像有个翻译员在你身边，每读一句英文就翻译一句中文，边听边翻译。

#### 程序的运行流程

我们平时写的代码（比如Rust、C、Python）其实是给人类自己看的"高级语言"，计算机本身是看不懂的。要让计算机执行，必须经过一系列"翻译"和"搬运"过程：

1. **编写代码（高级语言）**
   - 就像厨师写了一份详细的菜谱，描述每一步怎么做。
2. **编译器翻译成二进制（机器码）**
   - 编译器就像一个专业的翻译官，把菜谱（高级语言）翻译成只有厨师（CPU）能看懂的"数字指令"（机器码），这些指令全是0和1。
   - 这个过程会生成一个"可执行文件"，比如Windows下的`.exe`文件，Linux下的无扩展文件。
3. **存入硬盘**
   - 翻译好的"机器码"文件会被保存到硬盘，就像把菜谱打印好、装订成册，放进仓库。
4. **加载到内存**
   - 当你要运行程序时，操作系统会把硬盘上的可执行文件"搬运"到内存（操作台）上。
   - 只有放到内存里，CPU才能快速读取和执行。
5. **CPU执行指令**
   - CPU像一个超级快的厨师，按照内存里的"数字菜谱"一步步执行，把数据加工成你想要的结果。

##### 生活化比喻：
- 你写了一份菜谱（代码），请翻译官（编译器）翻译成只有厨师能懂的暗号（机器码），把这本暗号菜谱（可执行文件）放进仓库（硬盘）。
- 顾客点菜（你双击程序），服务员（操作系统）把菜谱从仓库搬到操作台（内存）。
- 厨师（CPU）在操作台上按照暗号菜谱做菜，最后把菜端给顾客（输出结果）。

##### 关键点总结：
- **编译器**：把人类写的代码翻译成机器能懂的二进制文件。
- **硬盘**：长期保存翻译好的程序。
- **内存**：程序运行时的"临时工作区"，速度快。
- **CPU**：真正执行指令的"大脑"。

这样，整个"写代码到程序运行"的流程就像写菜谱、翻译、存放、搬运、做菜、上菜一样，每一步都环环相扣。

### 2.0.4 操作系统的作用

操作系统负责管理硬件资源，为程序提供运行环境。它调度CPU、分配内存、管理文件和外设，让多个程序可以"看起来"同时运行。

### 2.0.5 进程与线程

- **进程**：可以理解为正在运行的一个"程序实例"，比如你同时开着微信和浏览器，这就是两个进程。每个进程有自己独立的内存空间，互不干扰。
    - 类比：进程就像一栋大楼里的不同公司，各自有自己的办公室和员工，互不打扰。
- **线程**：是进程内部的"执行小分队"，一个进程可以有多个线程同时工作。比如浏览器可以一边加载网页一边播放音乐，这通常是不同线程在协作。
    - 类比：线程就像公司里的不同部门，大家在同一个办公室里协作完成不同任务。

### 2.0.6 并发与并行

- **并发**：多个任务"轮流"执行，看起来像同时进行（单核CPU下的多任务切换）。
    - 类比：一个厨师轮流炒几道菜，虽然只有一口锅，但切换得快，顾客感觉每道菜都在做。
- **并行**：多个任务"真正"同时进行（多核CPU下，每个核各干一件事）。
    - 类比：几位厨师各自炒一道菜，真正同时出锅，效率更高。

### 2.0.7 变量、内存与地址

- **变量**：程序中用来存储数据的"名字"，比如`int a = 10;`，a就是变量名。
    - 类比：变量就像快递包裹上的标签，方便找到和区分不同的包裹。
- **内存地址**：每个变量在内存中都有唯一的编号（地址），可以用指针访问。
    - 类比：内存地址就像快递仓库里每个货架的位置编号。
- **指针**：存储变量地址的特殊变量，C语言常用，Rust有更安全的引用机制。
    - 类比：指针就像快递单，写着包裹存放的具体货架号。

### 2.0.8 文件与文件系统

- **文件**：数据的持久化存储单位，比如文档、图片、程序等。
    - 类比：文件就像家里的各种文件夹、照片、账本，长期保存。
- **文件系统**：操作系统用来管理文件和目录的方式，比如Windows的NTFS、Linux的ext4等。
    - 类比：文件系统就像图书馆的分类和借阅系统，帮你快速找到和管理书籍（文件）。
- 程序可以通过文件读写，把数据永久保存或读取出来。
    - 类比：你可以把重要资料存进保险柜（写文件），需要时再取出来（读文件）。

---

## 2.1 程序的编译与执行流程

在C语言和Rust中，程序的运行就像工厂生产一件商品，分为多个环节：

1. **预处理**：就像工厂在生产前先准备好原材料（比如把所有需要的零件、说明书都找齐）。C语言会把`#include`的头文件、宏定义等都整理好。
2. **编译**：把原材料加工成半成品。源代码（.c或.rs文件）被翻译成机器能理解的"零件"（目标文件.o）。
3. **链接**：把所有半成品组装成完整的商品。多个目标文件和库文件被合成一个可执行文件。
4. **运行**：商品出厂，送到用户手中。操作系统把可执行文件加载到内存，CPU开始执行。

| 阶段     | C语言                | Rust语言           |
|----------|----------------------|--------------------|
| 预处理   | #include/#define等   | 宏展开             |
| 编译     | 生成目标文件（.o）   | 生成目标文件（.o） |
| 链接     | 生成可执行文件       | 生成可执行文件     |
| 运行     | 操作系统加载执行     | 操作系统加载执行   |

#### 生活化比喻：
- 可以把整个流程想象成做一道菜：
    1. **预处理**：先把菜谱、食材、调料都准备好。
    2. **编译**：把食材切好、腌制、初步加工。
    3. **链接**：把所有配料和主菜一起下锅，做成成品。
    4. **运行**：把做好的菜端上桌，大家可以享用。

#### 静态编译型语言的优势
- C和Rust都属于"静态编译型语言"，就像工厂把所有零件都提前组装好，用户拿到手就是成品，直接用，不需要再加工。
- 这和"虚拟机"语言（如Java）不同，Java像是把半成品发给用户，用户家里还要有一台"虚拟机"来组装和运行，速度慢一些，也更依赖环境。

#### 具体意义
- Rust和C编译出来的程序可以直接在操作系统上运行，不需要额外的软件支持，启动快、效率高。
- 这就像你买到的家电插上电就能用，而不是还要自己组装一遍。

这样，哪怕你没有编程基础，也能直观理解"编译"、"链接"、"可执行文件"、"无需虚拟机"等术语背后的实际含义。

## 2.2 静态类型与动态类型

- **静态类型**（如C、Rust）：变量类型在编译期确定，运行效率高，出错早发现。
- **动态类型**（如Python、JavaScript）：变量类型在运行期确定，灵活但易出错。

Rust和C一样属于静态类型语言，但Rust支持类型推断，代码更简洁。例如：

```rust
let x = 42; // Rust会自动推断x为i32类型
```

## 2.3 内存管理方式的演变（深入讲解）

在C语言中，内存管理完全依赖开发者手动操作。比如：

```c
// C语言：手动分配和释放内存
int* p = (int*)malloc(sizeof(int));
*p = 42;
free(p); // 如果忘记free，就会内存泄漏
```

### 什么是"野指针"？

野指针指的是指向已经被释放或未初始化内存的指针。比如：

```c
int* p = (int*)malloc(sizeof(int));
free(p);
*p = 10; // 此时p已经是野指针，操作会导致未定义行为
```

这种错误在C/C++中很常见，可能导致程序崩溃甚至安全漏洞。

### Rust如何避免野指针？

Rust通过所有权和生命周期机制，保证变量离开作用域时自动释放内存，且禁止悬垂引用：

```rust
{
    let x = Box::new(42);
    // x在这里有效
} // 这里x自动释放，之后无法再访问x
// println!("{}", x); // 编译报错：x已被释放
```

Rust编译器会在编译期阻止所有悬垂指针和野指针的出现。

### 什么是"内存泄漏"？

内存泄漏是指程序分配了内存但没有释放，导致内存资源被长期占用。例如：

```c
void leak() {
    int* p = (int*)malloc(100);
    // 忘记free(p);
}
```

C/C++中这种问题很难彻底避免。

Rust的所有权机制让资源自动释放，极大降低了内存泄漏的风险。

---

## 2.4 栈与堆的基础知识（结合C与Rust对比）

- **栈**：像快递员送快递，先进后出，速度快，但空间有限。
- **堆**：像仓库，随时存取，但需要自己记得取回，否则会堆积成"垃圾"。

### C语言中的栈与堆

```c
void foo() {
    int a = 10;      // 栈分配，foo结束自动释放
    int* p = malloc(sizeof(int)); // 堆分配，需要手动free
    *p = 20;
    // ...
    free(p);         // 忘记就会泄漏
}
```

### Rust中的栈与堆

```rust
fn foo() {
    let a = 10;           // 栈分配，自动释放
    let p = Box::new(20); // 堆分配，离开作用域自动释放
    // ...
} // 这里p和a都被自动释放，无需手动管理
```

Rust的所有权和生命周期机制让你不用再担心"仓库忘记清理"的问题。

---

## 2.5 指针、引用与数据竞争（重点对比与举例）

### C语言的指针与常见问题

- **野指针**：指向无效内存。
- **悬垂指针**：指向已释放的内存。
- **数据竞争**：多线程同时读写同一内存，导致结果不可预测。

```c
// C语言多线程数据竞争示例（伪代码）
int counter = 0;
void* thread_func(void*) {
    for (int i = 0; i < 10000; ++i) {
        counter++; // 多线程下可能出现数据竞争
    }
}
```

如果两个线程同时修改counter，可能导致最终结果错误。

### Rust如何防止数据竞争？

Rust在编译期就会检查多线程共享变量的可变性和所有权，防止数据竞争：

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..2 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("结果: {}", *counter.lock().unwrap());
}
```

Rust强制你用Arc（原子引用计数）和Mutex（互斥锁）来保证多线程安全，编译器会阻止不安全的并发代码。

### Rust的引用安全

Rust区分可变引用（&mut T）和不可变引用（&T），同一时间只能有一个可变引用或多个不可变引用，杜绝了数据竞争和悬垂引用。

```rust
let mut x = 5;
let y = &mut x;
*y += 1;
// let z = &x; // 编译报错：不能同时有可变和不可变引用
```

这种严格的规则虽然一开始不太习惯，但极大提升了代码的安全性。

---

## 2.6 工程实践与团队协作初体验

Rust自带包管理和构建工具（cargo），新建、编译、测试、依赖管理一站式完成。推荐团队统一使用rustfmt（代码格式化）、clippy（代码静态检查），保证代码风格一致、质量可控。

- **文档注释**：使用`///`为函数和模块添加文档注释。
- **自动生成文档**：`cargo doc --open`可以生成并打开项目文档。
- **单元测试**：Rust内置测试框架，`cargo test`一键运行所有测试。

这些工具和规范，有助于团队协作和代码维护。

---

## 2.7 常见问题解答

- **Rust为什么没有GC？**
  Rust通过所有权和生命周期机制，在编译期自动管理内存，无需运行时GC，既安全又高效。
- **Rust和C++的RAII有什么不同？**
  Rust的所有权和借用机制更严格，能在编译期发现更多潜在问题，C++的RAII主要依赖开发者自律。
- **Rust适合哪些项目？**
  适合对安全性、性能要求高的系统级开发，如操作系统、嵌入式、Web后端、高性能服务等。
- **哪些场景下不建议用Rust？**
  对开发效率要求极高、生态依赖特定语言的快速原型开发，可能更适合用动态语言。

---

## 2.8 拓展阅读与社区资源

- [Rust官方文档](https://www.rust-lang.org/zh-CN/learn)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- [Awesome Rust](https://github.com/rust-unofficial/awesome-rust)
- [Rust中文社区](https://rustcc.cn/)

鼓励大家多参与社区讨论、提问和贡献代码，持续学习、共同进步！

---

## 2.9 小结与思考题

本章我们回顾了编程语言的发展，了解了Rust的诞生背景、设计目标和核心优势，并完成了开发环境的安装和第一个程序的编写。Rust以其独特的安全性和高性能，正在成为越来越多企业的首选。

### 思考题

1. 你认为C语言在现代开发中最大的优势和劣势分别是什么？
2. Rust的所有权机制能解决哪些C语言常见的bug？
3. 试着用C语言写一个"Hello, world!"程序，并与Rust的版本进行对比，有哪些异同？
