# 第二章：计算机基础与Rust定位

对于一些小白来说，第一章我们操作的安装Rust的操作，其实是一知半解的。Rust是一个编程语言 or 软件 or 什么别的？ `cargo`又是什么东西。其实在学习编程的时候，很多人都是被这些底层的原理给吓跑了，因为在学校的时候，我们只是按照书本上的内容进行操作，进行配置环境，但是问到这是怎么运行的，就会说："我不道啊，都是老师教的。"这一章就是用来补齐一些计算机基础，从第一步开始就**稳扎稳打、注重内力**，这不仅对学习Rust有帮助，这是学习任何计算机相关的知识的基础。本章会有非常多的反复的类比，旨在形象地强化一些概念。

## 2.1 计算机系统的基本组成

计算机系统主要由*硬件*和*软件*两大部分组成，二者密不可分：

- **硬件**：计算机的"躯壳"，包括CPU（中央处理器）、内存（RAM）、硬盘（存储）、输入输出设备（如键盘、鼠标、显示器等）。
- **软件**：计算机的"灵魂"，包括操作系统（如Windows、Linux、macOS）和各种应用程序（如微信、浏览器、游戏等）。软件通过一系列指令控制硬件完成各种任务。

也可以用厨房来比喻：

- **CPU** 就像厨师，负责思考和做菜（处理数据和指令）。
- **内存** 就像操作台，厨师把正在做的菜和用到的食材都放在这里，方便随时拿取。
- **硬盘** 就像储藏室，存放大量还没用到的食材和工具，需要时再拿出来。
- **输入设备**（如键盘、鼠标）就像点菜的顾客或送菜的服务员，把需求和信息传递给厨师。
- **输出设备**（如显示器、打印机）就像上菜窗口，把做好的菜端给顾客。
- **软件** 就像菜谱和餐厅的规则，指导厨师和服务员如何协作。

整个厨房高效运作，离不开每个环节的协作，这就像计算机硬件和软件的分工一样。

### 思考与解释：
- **为什么内存比硬盘小很多，但速度快很多？**
    - 类比：
      - 操作台（内存）空间有限，但厨师可以非常快地拿取和处理。
      - 储藏室（硬盘）空间大，但每次取用都要走一趟，速度慢得多。
    - 内存技术快但贵，硬盘容量大但慢。
- **为什么不能把所有东西都放在内存？**
    - 操作台太大既贵又占地方，很多食材暂时用不到，放在储藏室更合适。
- **为什么程序运行时要"加载"到内存？**
    - 就像厨师做菜前要把食材从储藏室拿到操作台，程序运行前也要把数据和指令从硬盘搬到内存，CPU才能高效处理。

## 2.2 软件是如何运行的


### 2.2.1 编程语言和编译器

计算机只能识别0和1（二进制），所有数据和指令最终都要转成0/1（二进制文件）。十六进制常用于表示内存地址和数据，便于阅读和调试。
而人类能理解的语言是自然语言，例如英语。所以如何让计算机理解人类的指令是很关键的。

**而自然语言是有歧义的。**例如：这个人的头发长得奇怪。究竟是头发长度长的奇怪，还是头发的形状看起来奇怪？
那么，我们就需要一种人类能够理解的，能够翻译成0和1二进制代码的，无二义性的东西，作为人和计算机之间的桥梁。

**高级编程语言**应运而生。而从人类编写的高级编程语言到机器能懂的二进制语言之间，需要一个翻译器 —— **编译器（解释器）**

- **编译器**：一种特殊的软件工具（"翻译器"），能把我们写的"高级语言"代码（如C、Rust）一次性翻译成计算机能直接执行的"机器码"，生成可执行文件，运行速度快。
- **解释器**：像"翻译员"，每次运行时逐行翻译代码，边翻译边执行，灵活但速度慢（如Python、JavaScript）。

为什么会有两种不同的翻译器呢？其实，这和不同的需求和历史发展有关：

- **编译器**（如C、Rust）：
    - 优点：一次性把全部代码翻译成机器码，生成可执行文件，运行速度快，适合对性能要求高的场景。
    - 缺点：每次修改代码都要重新编译，开发调试周期稍长。
    - 适用场景：操作系统、游戏、服务器等需要高性能的程序。
    - 类比：像把一本英文小说全部翻译成中文再出版，读者可以直接看中文版，阅读体验流畅。

- **解释器**（如Python、JavaScript）：
    - 优点：可以边写边运行，修改一行代码马上看到效果，开发效率高，适合快速试验和学习。
    - 缺点：每次运行都要"翻译"一遍，速度慢一些。
    - 适用场景：脚本、自动化、数据分析、网页前端等对性能要求不高、但开发灵活性要求高的场合。
    - 类比：像有个翻译员在你身边，每读一句英文就翻译一句中文，虽然灵活但速度慢。

**历史背景**：早期计算机资源有限，大家更关注运行效率，所以C、C++等编译型语言流行。随着计算机变快，开发效率变得更重要，解释型语言（如Python）开始流行，适合快速开发和原型设计。

我们在第一章安装的软件里面，其中一个很关键的就是编译器。Rust的编译器叫做rustc，而c、c++的编译器主流是gcc、g++、clang、clang++等。

### 2.2.2 程序的运行流程

程序的运行大致分为以下几个步骤：

1. **编写代码（高级语言）**。开发者使用如Rust、C、Python等高级编程语言编写源代码。
1. **编译/解释生成二进制文件**。源代码通过编译器（如rustc、gcc）或解释器（如python）被翻译成计算机能直接执行的机器码（二进制指令）。编译型语言会生成可执行文件，解释型语言则在运行时逐行翻译执行。
1. **存入硬盘**。编译生成的可执行二进制文件或脚本文件被保存到硬盘等存储介质中。
1. **操作系统加载到内存**。当用户运行程序时，操作系统会将可执行文件从硬盘加载到内存。只有在内存中的程序才能被CPU访问和执行。
1. **CPU执行指令**。CPU从内存中读取指令，逐条执行，实现程序的功能。

简而言之：代码经过编译/解释后生成二进制文件，存储在硬盘，运行时由操作系统加载到内存，最终由CPU执行。

## 2.3 操作系统基础

操作系统（Operating System, OS）是管理和协调计算机硬件与软件资源的核心系统软件。

> 例子：Windows、Linux、macOS、Android

直观来看，操作系统就是给我们提供用户界面的一个东西，方便我们操作。
但实际上，并不是这样，图形用户界面（GUI）只是操作系统很小的一部分！

### 操作系统到底是什么？

这里是一个主板，有非常复杂的硬件：
![主板](./assets/cpu.png)


如果没有操作系统，每个我们编写的程序都必须自己负责：
如何让CPU执行自己的指令；
如何分配和管理内存；
如何读写硬盘、显示内容、响应键盘鼠标等外设；
如何和其他程序"和平共处"，避免互相干扰。
这会让每个程序都变得极其复杂，而且容易出错，甚至会导致系统崩溃或数据丢失。

操作系统的作用就是：
- 统一管理和调度硬件资源，简化程序开发；
- 让多个程序可以安全、稳定地同时运行，互不干扰；
- 提供标准的接口和服务（如文件系统、网络、图形界面等），让开发者专注于自己的业务逻辑。

有了操作系统，开发者只需要关心"做什么"，而不必关心"怎么和硬件打交道"，大大提升了开发效率和系统安全性。

在程序运行过程中，操作系统负责下面的工作：
- 把程序从硬盘加载到内存；
- 分配CPU资源让程序执行；
- 管理程序运行时产生的数据和文件；
- 处理输入输出（如键盘、鼠标、网络等）。

这样我们编写的程序只需要调用下面这样的接口就好了。

对于c语言：
```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("test.txt", "w"); // 打开文件，写入模式
    if (fp == NULL) {
        printf("无法打开文件\n");
        return 1;
    }
    fprintf(fp, "Hello, world!\n"); // 写入内容
    fclose(fp); // 关闭文件
    return 0;
}
```

对于Rust：
```rust
use std::fs::File;
use std::io::Write;

fn main() {
    let mut file = File::create("test.txt").expect("无法创建文件");
    file.write_all(b"Hello, world!\n").expect("写入失败");
}

```

否则，我们就要手动用代码操纵磁盘，来读取，这是非常痛苦且低效的！！！
简而言之，操作系统是所有程序运行的"总管"，没有操作系统，绝大多数应用程序都无法独立运行。
操作系统为我们提供了很多接口，用于管理和控制硬件，下面我会以C和Rust的例子来阐释。

### 进程与线程、并发与并行

在现代操作系统中，**进程**和**线程**是实现多任务的两种基本单位。

- **进程**：可以理解为正在运行的一个"程序实例"。比如你同时开着微信和浏览器，这就是两个进程。每个进程有自己独立的内存空间，互不干扰。
  - 类比：进程就像一栋大楼里的不同公司，各自有自己的办公室和员工，互不打扰。

- **线程**：是进程内部的"执行小分队"，一个进程可以有多个线程同时工作。比如浏览器可以一边加载网页一边播放音乐，这通常是不同线程在协作。
  - 类比：线程就像公司里的不同部门，大家在同一个办公室里协作完成不同任务。

#### 并发与并行

- **并发**：指的是多个任务"轮流"执行，看起来像同时进行（比如单核CPU下的多任务切换）。
  - 类比：一个厨师轮流炒几道菜，虽然只有一口锅，但切换得快，顾客感觉每道菜都在做。
- **并行**：指的是多个任务"真正"同时进行（比如多核CPU下，每个核各干一件事）。
  - 类比：几位厨师各自炒一道菜，真正同时出锅，效率更高。

#### 为什么要有进程和线程？

有了操作系统，我们只需要用简单的接口就能让程序"多线程"运行，无需自己管理底层的CPU调度和资源分配。

#### 代码示例

**C语言：**
```c
#include <pthread.h>
void* thread_func(void* arg) {
    // 线程要做的事情
}
int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, thread_func, NULL); // 创建线程
    pthread_join(tid, NULL); // 等待线程结束
    return 0;
}
```

**Rust：**
```rust
use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        // 线程要做的事情
    });
    handle.join().unwrap(); // 等待线程结束
}
```

> 只需几行代码，就能让程序同时做多件事。底层的线程调度、资源分配都由操作系统负责，开发者不用操心。

#### 小结

- 进程和线程让程序能"同时"做多件事，提升效率和响应速度。
- 并发和并行是实现多任务的两种方式，操作系统会根据硬件自动安排。
- C和Rust都提供了标准接口，开发者只需调用，无需关心底层细节。

### 变量、内存与地址

我们只需声明变量，系统自动分配内存。需要获取地址时，也有标准写法。

**C语言：**
```c
int a = 10; //底层是编程语言操作操作系统在内存里开辟一块新区域
int* p = &a; // 获取变量a在内存里的地址
```
**Rust：**
```rust
let a = 10;
let p = &a; // 获取变量a的引用
```
> 不用关心内存的具体分配细节，操作系统和语言帮我们管理好。

### 文件与文件系统

如前所述，读写文件只需调用标准接口。

**C语言：**
```c
fopen("test.txt", "w"); // 打开文件
```
**Rust：**
```rust
File::create("test.txt"); // 创建文件
```
> 不用自己操作磁盘硬件，操作系统帮我们完成所有底层工作。

---

## 2.4 程序的编译与执行流程

我们平时写的代码（无论是C还是Rust），其实只是"说明书"或者"菜谱"，计算机本身是看不懂的。要让计算机真正执行你的指令，需要经过一系列"翻译"和"加工"过程。

### 2.4.1 从代码到程序：像工厂生产商品

可以把整个过程想象成工厂生产商品：

1. **编写源代码**  
   你写的C或Rust代码，就像是产品的设计图纸。

2. **编译/翻译**  
   编译器（如gcc、rustc）就像工厂的翻译和加工机器，把你的设计图纸翻译成零件（机器码/目标文件）。

3. **链接/组装**  
   链接器把所有零件（目标文件、库文件）组装成一个完整的产品（可执行文件）。

4. **运行/交付**  
   操作系统像物流，把产品送到用户手中（把程序加载到内存，交给CPU执行）。

| 阶段     | C语言                | Rust语言           |
|----------|----------------------|--------------------|
| 编译     | gcc main.c -o main   | rustc main.rs      |
| 运行     | ./main               | ./main             |

> **小结**：你只需要写好"说明书"，剩下的翻译、组装、交付都由编译器和操作系统帮你搞定。

---

### 2.4.2 静态类型与动态类型

- **静态类型**（如C、Rust）：变量的类型在编译时就确定了，出错能早发现，运行更快。
- **动态类型**（如Python、JavaScript）：变量类型在运行时才确定，写起来灵活，但容易出错。

**对比示例：**

C/Rust（静态类型）：
```c
int a = 10; // a只能是整数
```
```rust
let a: i32 = 10; // a只能是整数
```

Python（动态类型）：
```python
a = 10
a = "hello" # 也可以变成字符串
```

> Rust和C一样，属于静态类型语言，但Rust支持类型推断，代码更简洁。

---

### 2.4.3 内存管理方式的演变

在C语言中，内存管理完全靠开发者自己，容易出错：

```c
int* p = (int*)malloc(sizeof(int)); // 手动分配内存
*p = 42;
free(p); // 手动释放内存，忘了就会泄漏
```

**常见问题：**
- **野指针**：指向已经被释放或未初始化的内存，操作会导致崩溃或安全漏洞。
- **内存泄漏**：分配了内存但忘记释放，程序越跑越慢，最终崩溃。

Rust的做法更安全：

```rust
{
    let x = Box::new(42); // 自动分配和释放内存
    // x在这里有效
} // 这里x自动释放，之后无法再访问x
// println!("{}", x); // 编译报错：x已被释放
```

> Rust通过所有权和生命周期机制，自动管理内存，极大降低了野指针和内存泄漏的风险。

---

### 2.4.4 栈与堆的基础知识

- **栈**：像快递员送快递，先进后出，速度快，但空间有限。
- **堆**：像仓库，随时存取，但需要自己记得取回，否则会堆积成"垃圾"。

**C语言：**
```c
void foo() {
    int a = 10;      // 栈分配，自动释放
    int* p = malloc(sizeof(int)); // 堆分配，需要手动free
    *p = 20;
    free(p);         // 忘记就会泄漏
}
```

**Rust：**
```rust
fn foo() {
    let a = 10;           // 栈分配，自动释放
    let p = Box::new(20); // 堆分配，离开作用域自动释放
} // p和a都被自动释放，无需手动管理
```

> Rust让你不用再担心"仓库忘记清理"的问题。

---

### 2.4.5 指针、引用与数据竞争

- **C语言的指针**：灵活但危险，容易出现野指针、悬垂指针和数据竞争。
- **Rust的引用**：更安全，编译器会帮你检查，防止悬垂引用和数据竞争。

**C语言多线程数据竞争示例：**
```c
int counter = 0;
void* thread_func(void*) {
    for (int i = 0; i < 10000; ++i) {
        counter++; // 多线程下可能出现数据竞争
    }
}
```

**Rust多线程安全示例：**
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..2 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("结果: {}", *counter.lock().unwrap());
}
```

> Rust强制你用Arc和Mutex来保证多线程安全，编译器会阻止不安全的并发代码。

## 2.5 内存管理方式的演变（深入讲解）

在C语言中，内存管理完全依赖开发者手动操作。比如：

```c
// C语言：手动分配和释放内存
int* p = (int*)malloc(sizeof(int));
*p = 42;
free(p); // 如果忘记free，就会内存泄漏
```

### 什么是"野指针"？

野指针指的是指向已经被释放或未初始化内存的指针。比如：

```c
int* p = (int*)malloc(sizeof(int));
free(p);
*p = 10; // 此时p已经是野指针，操作会导致未定义行为
```

这种错误在C/C++中很常见，可能导致程序崩溃甚至安全漏洞。

### Rust如何避免野指针？

Rust通过所有权和生命周期机制，保证变量离开作用域时自动释放内存，且禁止悬垂引用：

```rust
{
    let x = Box::new(42);
    // x在这里有效
} // 这里x自动释放，之后无法再访问x
// println!("{}", x); // 编译报错：x已被释放
```

Rust编译器会在编译期阻止所有悬垂指针和野指针的出现。

### 什么是"内存泄漏"？

内存泄漏是指程序分配了内存但没有释放，导致内存资源被长期占用。例如：

```c
void leak() {
    int* p = (int*)malloc(100);
    // 忘记free(p);
}
```

C/C++中这种问题很难彻底避免。

Rust的所有权机制让资源自动释放，极大降低了内存泄漏的风险。

---

## 2.6 栈与堆的基础知识（结合C与Rust对比）

- **栈**：像快递员送快递，先进后出，速度快，但空间有限。
- **堆**：像仓库，随时存取，但需要自己记得取回，否则会堆积成"垃圾"。

### C语言中的栈与堆

```c
void foo() {
    int a = 10;      // 栈分配，foo结束自动释放
    int* p = malloc(sizeof(int)); // 堆分配，需要手动free
    *p = 20;
    // ...
    free(p);         // 忘记就会泄漏
}
```

### Rust中的栈与堆

```rust
fn foo() {
    let a = 10;           // 栈分配，自动释放
    let p = Box::new(20); // 堆分配，离开作用域自动释放
    // ...
} // 这里p和a都被自动释放，无需手动管理
```

Rust的所有权和生命周期机制让你不用再担心"仓库忘记清理"的问题。

---

## 2.7 指针、引用与数据竞争（重点对比与举例）

### C语言的指针与常见问题

- **野指针**：指向无效内存。
- **悬垂指针**：指向已释放的内存。
- **数据竞争**：多线程同时读写同一内存，导致结果不可预测。

```c
// C语言多线程数据竞争示例（伪代码）
int counter = 0;
void* thread_func(void*) {
    for (int i = 0; i < 10000; ++i) {
        counter++; // 多线程下可能出现数据竞争
    }
}
```

如果两个线程同时修改counter，可能导致最终结果错误。

### Rust如何防止数据竞争？

Rust在编译期就会检查多线程共享变量的可变性和所有权，防止数据竞争：

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..2 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("结果: {}", *counter.lock().unwrap());
}
```

Rust强制你用Arc（原子引用计数）和Mutex（互斥锁）来保证多线程安全，编译器会阻止不安全的并发代码。

### Rust的引用安全

Rust区分可变引用（&mut T）和不可变引用（&T），同一时间只能有一个可变引用或多个不可变引用，杜绝了数据竞争和悬垂引用。

```rust
let mut x = 5;
let y = &mut x;
*y += 1;
// let z = &x; // 编译报错：不能同时有可变和不可变引用
```

这种严格的规则虽然一开始不太习惯，但极大提升了代码的安全性。

---

## 2.8 工程实践与团队协作

Rust自带包管理和构建工具（cargo），新建、编译、测试、依赖管理一站式完成。推荐团队统一使用rustfmt（代码格式化）、clippy（代码静态检查），保证代码风格一致、质量可控。

- **文档注释**：使用`///`为函数和模块添加文档注释。
- **自动生成文档**：`cargo doc --open`可以生成并打开项目文档。
- **单元测试**：Rust内置测试框架，`cargo test`一键运行所有测试。

这些工具和规范，有助于团队协作和代码维护。

---

## 2.9 常见问题解答

- **Rust为什么没有GC？**
  Rust通过所有权和生命周期机制，在编译期自动管理内存，无需运行时GC，既安全又高效。
- **Rust和C++的RAII有什么不同？**
  Rust的所有权和借用机制更严格，能在编译期发现更多潜在问题，C++的RAII主要依赖开发者自律。
- **Rust适合哪些项目？**
  适合对安全性、性能要求高的系统级开发，如操作系统、嵌入式、Web后端、高性能服务等。
- **哪些场景下不建议用Rust？**
  对开发效率要求极高、生态依赖特定语言的快速原型开发，可能更适合用动态语言。


## 2.10 小结与思考题

本章我们回顾了编程语言的发展，了解了Rust的诞生背景、设计目标和核心优势，并完成了开发环境的安装和第一个程序的编写。Rust以其独特的安全性和高性能，正在成为越来越多企业的首选。

### 思考题

1. 你认为C语言在现代开发中最大的优势和劣势分别是什么？
2. Rust的所有权机制能解决哪些C语言常见的bug？
3. 试着用C语言写一个"Hello, world!"程序，并与Rust的版本进行对比，有哪些异同？
