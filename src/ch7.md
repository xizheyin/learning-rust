# 第七章 流程控制与模式匹配

## 引子：为什么程序需要"思考"？

我们在小学时候有一个很经典的问题，有两种电费计算方式，我选哪种比较划算？

**第一种计费方法** "这个月用了100度电，电费就是100元。"

**第二种计费方法** 你突然想起电力公司最近推出了阶梯电价政策：
- 前50度电：0.8元/度
- 50-100度电：1.2元/度
- 超过100度电：1.5元/度

我们的解题思路是这样：
先设一个月用x度电，费用为y，那么：
1. 当`x<=50`时，电费y为 `y=0.8x`
2. 当`50<x<=100`时，电费y为`y=0.8*50+1.2*(x-50)`，即`y=1.2x-20`
3. 当`x>100`时，电费y为`y=0.8*50+1.2*(100-50)+1.5*(x-100)`，即`y=1.5-50`

那么我们通过画一个折线图就能看出来，当一个月用电量小于等于100度时，选第一种方案；否则选第二种。

这个简单的电费计算过程，实际上展示了人类思维中的"决策"和"判断"能力。
电费根据不同用电量有不同的计算方法；人们可以根据不同的用电量选择不同的方案。
生活中处处充满了决策......



### 人类思维中的控制流

在日常生活中，我们的思维过程充满了各种"如果...那么..."的判断：

**决策过程：**
- 如果下雨，那么带伞
- 如果饿了，那么吃饭
- 如果困了，那么睡觉
- 如果时间不够，那么选择最快的路线

**重复过程：**
- 每天都要刷牙、洗脸、吃饭
- 每周都要检查邮箱、处理邮件
- 每个月都要还房贷、交水电费

这些思维模式正是程序需要模拟的。程序不仅要能够进行简单的计算，更要能够根据不同的情况做出不同的选择，能够重复执行相同的操作来处理大量数据。

### 从简单计算到智能判断

**没有"思考"能力的程序：**
```rust
// 只能做固定的事情
let electricity = 100;
let bill = electricity * 1.0;  // 固定单价
println!("电费：{}元", bill);
```

**有"思考"能力的程序：**
```rust
// 能够根据情况做出不同选择
let electricity = 100;
let bill = if electricity <= 50 {
    electricity as f64 * 0.8
} else if electricity <= 100 {
    50.0 * 0.8 + (electricity - 50) as f64 * 1.2
} else {
    // 更复杂的计算...
    50.0 * 0.8 + 50.0 * 1.2 + (electricity - 100) as f64 * 1.5
};
println!("电费：{}元", bill);
```

### 控制流的三大支柱

控制流让程序从"计算器"变成"智能助手"：

**1. 条件判断** - 让程序能够"思考"和"选择"
就像人类会根据天气决定是否带伞一样，程序需要根据**数据的不同特征**做出不同的处理。

**2. 循环** - 让程序能够"重复"和"批量处理"  
就像人类会重复执行日常任务一样，程序需要能够重复处理大量数据，而不需要为每个数据项编写重复的代码。

**3. 模式匹配** - 让程序能够"识别"和"分类"
就像人类能够识别不同类型的邮件并分类处理一样，程序需要能够根据数据的"形状"或"特征"来做出精确的判断。

### 为什么控制流如此重要？

控制流是编程的核心，它让程序从静态的计算工具变成动态的智能系统。没有控制流的程序就像一台只能按照固定公式计算的机器，无法适应复杂多变的现实世界。
通过控制流，程序能够根据不同的输入做出不同的响应，实现复杂的业务规则和算法，批量处理大量数据，处理各种异常情况和边界条件。
在这一章中，我们将学习如何让程序具备"思考"能力，掌握条件判断、循环结构和模式匹配的使用方法，从而编写出真正智能的程序。

---

## 7.1 条件语句：让程序做选择

**什么是条件语句？**

条件语句是编程中最基本也是最重要的控制流结构之一，它让程序能够根据不同的情况做出不同的选择。就像人类在日常生活中会面临各种选择一样，程序也需要根据输入数据的不同特征来决定执行什么样的操作。

在日常生活中，我们经常需要根据条件做出决策：如果下雨，我们会带伞；如果饿了，我们会吃饭；如果困了，我们会睡觉。这些"如果...那么..."的逻辑，就是条件判断的基本形式。在编程中，我们用条件语句来实现这种逻辑，让程序能够模拟人类的决策过程。

条件语句的核心思想是：当某个条件为真时，执行特定的代码块；当条件为假时，可以选择执行其他代码块或者跳过执行。这种能力使程序从简单的顺序执行变成了能够根据情况做出判断的智能系统。

### 基本的if语句：程序决策的起点

最简单的条件语句就是`if`语句，它构成了程序决策能力的基础。`if`语句允许程序在特定条件满足时执行一段代码，在条件不满足时跳过这段代码。

```rust
let score = 85;

if score >= 60 {
    println!("恭喜，你及格了！");
}
```

在这个例子中，程序会检查变量`score`的值是否大于等于60。如果这个条件为真，程序就会执行大括号内的代码，输出"恭喜，你及格了！"；如果条件为假，程序就会跳过这段代码，继续执行后面的语句。

**语法解释：**
`if`语句的语法结构非常直观：`if`关键字后面跟着一个条件表达式，这个表达式必须产生一个布尔值（`true`或`false`）。当条件为真时，程序会执行紧随其后的大括号`{}`内的代码块；当条件为假时，程序会跳过这个代码块，继续执行后面的代码。

这种设计使得程序能够根据数据的特征做出响应，而不是盲目地执行所有代码。例如，在成绩判断系统中，只有当学生的成绩达到及格线时，程序才会输出祝贺信息，这种智能化的响应正是条件语句的价值所在。

### if-else语句：处理两种对立的情况

在实际编程中，我们经常需要处理两种对立的情况：当条件为真时执行一种操作，当条件为假时执行另一种操作。`if-else`语句正是为这种需求而设计的。

```rust
let score = 55;

if score >= 60 {
    println!("恭喜，你及格了！");
} else {
    println!("很遗憾，你需要补考。");
}
```

在这个例子中，程序会根据成绩是否达到60分来做出不同的响应。如果成绩大于等于60分，程序会输出祝贺信息；如果成绩小于60分，程序会输出需要补考的提示。这种双向选择的能力使程序能够提供更加人性化和实用的反馈。

**语法解释：**
`if-else`语句扩展了基本的`if`语句，增加了`else`分支来处理条件为假的情况。当`if`条件为真时，程序执行第一个大括号内的代码块；当条件为假时，程序执行`else`后面大括号内的代码块。这种结构确保了无论条件如何，程序都会执行相应的操作，避免了程序在某些情况下没有响应的问题。

### if-else if-else语句：处理多种复杂情况

在现实世界中，我们经常需要根据多个不同的条件做出不同的选择。例如，在成绩评估系统中，我们可能需要根据分数范围给出不同的等级评价。`if-else if-else`语句正是为处理这种复杂情况而设计的。

```rust
let score = 85;

if score >= 90 {
    println!("优秀！");
} else if score >= 80 {
    println!("良好！");
} else if score >= 70 {
    println!("中等！");
} else if score >= 60 {
    println!("及格！");
} else {
    println!("不及格！");
}
```

在这个例子中，程序会根据成绩的不同范围给出相应的评价。这种多分支的条件判断使程序能够处理复杂的业务逻辑，提供更加精确和细致的响应。

**执行顺序：**
`if-else if-else`语句的执行遵循从上到下的顺序。程序首先检查第一个`if`条件，如果为真，执行相应的代码块并结束整个条件判断；如果为假，程序会继续检查下一个`else if`条件，依此类推。只有当所有条件都为假时，程序才会执行最后的`else`分支。

这种顺序执行的设计使得我们能够按照优先级来处理不同的情况，确保最重要的条件得到优先检查。例如，在成绩评估中，我们通常会先检查是否达到优秀标准，然后依次检查良好、中等、及格等标准，这种优先级设计符合人类的思维习惯。

### if表达式：Rust语言的独特优势

Rust语言在条件语句方面有一个独特的优势：`if`语句不仅可以用来执行代码，还可以用来返回值。这种特性使得`if`语句可以作为表达式使用，大大提高了代码的简洁性和可读性。

```rust
let score = 85;
let grade = if score >= 90 {
    "A"
} else if score >= 80 {
    "B"
} else if score >= 70 {
    "C"
} else if score >= 60 {
    "D"
} else {
    "F"
};

println!("你的等级是：{}", grade);
```

在这个例子中，`if`语句被用来给变量`grade`赋值。根据成绩的不同范围，`if`表达式会返回不同的字符串值，这些值被直接赋给`grade`变量。这种写法比传统的条件赋值更加简洁和直观。

**重要特点：**
`if`表达式有几个重要的特点需要注意。首先，每个分支的返回值类型必须相同，这是Rust类型系统的要求，确保了类型安全。其次，所有分支都必须有返回值，包括`else`分支，这确保了表达式在任何情况下都会产生一个值。最后，这种特性是Rust语言的独特功能，大多数其他编程语言都不支持这种用法。

这种设计使得Rust代码更加函数式和声明式，减少了临时变量的使用，提高了代码的表达能力。例如，我们可以直接在函数返回语句中使用`if`表达式，而不需要先声明一个变量来存储中间结果。

### 与C语言的对比：理解Rust的设计理念

通过对比C语言和Rust的条件语句，我们可以更好地理解Rust语言的设计理念和优势。

**C语言的条件语句：**
```c
int score = 85;
if (score >= 90) {
    printf("优秀！\n");
} else if (score >= 80) {
    printf("良好！\n");
} else {
    printf("继续努力！\n");
}
```

**Rust的条件语句：**
```rust
let score = 85;
if score >= 90 {
    println!("优秀！");
} else if score >= 80 {
    println!("良好！");
} else {
    println!("继续努力！");
}
```

**主要区别：**
Rust和C语言在条件语句方面有几个重要的区别。首先，Rust不需要用括号包围条件表达式，虽然可以加括号，但这不是必需的。这种设计使得Rust代码看起来更加简洁。其次，Rust的条件表达式必须是布尔值，不能是数字或其他类型，这确保了类型安全，避免了C语言中常见的错误，比如在条件中误用赋值运算符。最后，Rust支持`if`表达式，这是C语言所不具备的功能，使得Rust代码更加灵活和表达力强。

这些区别反映了Rust语言的设计哲学：强调类型安全、代码简洁性和表达能力。通过这些设计，Rust试图在保持高性能的同时，提供更好的开发体验和更少的运行时错误。

### 条件表达式的注意事项：避免常见错误

虽然`if`表达式非常有用，但在使用时需要注意一些细节，以避免常见的错误。

**错误示例：**
```rust
let score = 85;
let grade = if score >= 90 {
    "A"
} else if score >= 80 {
    "B"
}; // 错误！缺少else分支
```

**正确示例：**
```rust
let score = 85;
let grade = if score >= 90 {
    "A"
} else if score >= 80 {
    "B"
} else {
    "C"  // 必须有else分支
};
```

在`if`表达式中，所有分支都必须有返回值，包括`else`分支。这是因为表达式必须能够在任何情况下都产生一个值，以便赋给变量或用于其他用途。如果缺少`else`分支，编译器会报错，提示表达式可能不会产生值。

这种要求虽然看起来有些严格，但实际上有助于编写更加健壮的代码。它迫使程序员考虑所有可能的情况，确保程序在任何输入下都能正常工作。这种设计体现了Rust语言"零成本抽象"的理念：在不增加运行时开销的情况下，提供编译时的安全保障。

### 实际应用：电费计算的完整实现

让我们通过一个完整的电费计算程序来展示条件语句在实际应用中的价值。这个程序将实现阶梯电价的计算逻辑，展示如何使用条件语句来处理复杂的业务规则。

```rust
fn calculate_electricity_bill(usage: f64) -> f64 {
    if usage <= 50.0 {
        usage * 0.8
    } else if usage <= 100.0 {
        50.0 * 0.8 + (usage - 50.0) * 1.2
    } else {
        50.0 * 0.8 + 50.0 * 1.2 + (usage - 100.0) * 1.5
    }
}

fn main() {
    let usage1 = 30.0;
    let usage2 = 80.0;
    let usage3 = 120.0;
    
    println!("用电{}度，电费：{:.2}元", usage1, calculate_electricity_bill(usage1));
    println!("用电{}度，电费：{:.2}元", usage2, calculate_electricity_bill(usage2));
    println!("用电{}度，电费：{:.2}元", usage3, calculate_electricity_bill(usage3));
}
```

这个程序展示了如何使用条件语句来实现复杂的业务逻辑。函数`calculate_electricity_bill`接收用电量作为参数，然后根据不同的用电量范围使用不同的计费标准。当用电量小于等于50度时，按照0.8元/度的标准计算；当用电量在50到100度之间时，前50度按0.8元计算，超出部分按1.2元计算；当用电量超过100度时，还需要考虑更高的阶梯标准。

**运行结果：**
```
用电30度，电费：24.00元
用电80度，电费：76.00元
用电120度，电费：130.00元
```

这个例子清楚地展示了条件语句如何使程序能够根据不同的输入数据做出不同的处理，从而产生符合实际业务需求的结果。没有条件语句，我们就无法实现这种复杂的业务逻辑，程序就只能按照固定的公式进行计算。

### 小结：条件语句的核心价值

条件语句是编程中最基本也是最重要的控制流结构之一，它让程序从简单的顺序执行变成了能够根据情况做出判断的智能系统。通过`if`、`else`、`else if`等关键字，我们可以构建复杂的决策逻辑，使程序能够模拟人类的思维过程。

Rust语言在条件语句方面提供了独特的优势，特别是`if`表达式的支持，使得代码更加简洁和表达力强。同时，Rust的类型系统确保了条件表达式的类型安全，避免了其他语言中常见的错误。

条件语句的应用范围非常广泛，从简单的数值比较到复杂的业务逻辑判断，都离不开条件语句的支持。掌握条件语句的使用方法，是成为合格程序员的基本要求，也是编写高质量软件的重要基础。

## 7.2 循环结构：让程序重复执行操作

**什么是循环？**

循环是编程中另一个核心的控制流结构，它让程序能够重复执行相同的操作，而不需要为每个操作编写重复的代码。就像人类在日常生活中会重复执行某些任务一样，程序也需要通过循环来处理大量数据或执行重复性的操作。

在日常生活中，我们每天都会重复执行一些基本任务：刷牙、洗脸、吃饭、上班等。这些重复性的活动构成了我们日常生活的基础。在编程中，循环就是实现这种重复执行能力的机制，它使程序能够高效地处理大量数据，执行复杂的算法，或者实现持续运行的服务。

循环的核心思想是：在满足特定条件的情况下，重复执行一段代码块，直到条件不再满足为止。这种能力使程序从单次处理转变为批量处理，大大提高了程序的效率和实用性。没有循环的程序就像只能处理单个订单的收银员，无法应对繁忙的商业环境。

### 为什么需要循环？从手动计算到自动化处理

要理解循环的重要性，我们可以通过一个简单的例子来说明。假设你需要计算1到100的和，如果不用循环，你需要手动写出所有的加法运算。

**没有循环的方式：**
```rust
let sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 
          11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 +
          // ... 要写100行！
          99 + 100;
```

这种方式不仅代码冗长，而且容易出错。如果要求计算1到1000的和，这种方法就变得完全不实用。更重要的是，这种硬编码的方式缺乏灵活性，无法处理动态的数据范围。

**使用循环的方式：**
```rust
let mut sum = 0;
for i in 1..=100 {
    sum = sum + i;
}
println!("1到100的和是：{}", sum);
```

通过循环，我们只需要几行代码就能完成相同的计算，而且这种方法可以轻松扩展到任意范围。循环不仅使代码更加简洁，更重要的是使程序具有了处理动态数据的能力。

### Rust的三种循环：适应不同的使用场景

Rust语言提供了三种不同类型的循环结构，每种都有其特定的使用场景和优势。理解这些循环的特点和适用情况，对于编写高效和可读的代码至关重要。

#### 1. for循环：遍历集合和范围的标准方式

`for`循环是Rust中最常用的循环类型，它专门设计用于遍历范围、数组、向量等集合类型的数据。`for`循环的语法简洁明了，使用起来非常直观。

```rust
// 遍历数字范围
for i in 1..=5 {
    println!("第{}次循环", i);
}

// 遍历数组
let fruits = ["苹果", "香蕉", "橙子"];
for fruit in fruits.iter() {
    println!("我喜欢吃{}", fruit);
}

// 遍历字符串的字符
for c in "Hello".chars() {
    println!("字符：{}", c);
}
```

**范围语法详解：**
Rust提供了灵活的范围语法来定义循环的迭代范围。`1..5`表示从1到4的整数序列（不包含5），`1..=5`表示从1到5的整数序列（包含5），`0..10`表示从0到9的整数序列。这种语法设计使得循环的边界条件非常清晰，避免了其他语言中常见的边界错误。

`for`循环的优势在于它的安全性和简洁性。Rust的`for`循环不会出现数组越界的错误，因为编译器会确保迭代器在有效范围内工作。同时，`for`循环的语法非常直观，使得代码的意图一目了然。

#### 2. while循环：基于条件的重复执行

`while`循环在条件为真时重复执行代码块，直到条件变为假为止。这种循环特别适合那些循环次数不确定，但循环条件明确的情况。

```rust
let mut count = 0;
while count < 5 {
    println!("count = {}", count);
    count = count + 1;
}
```

`while`循环的核心是条件表达式，这个表达式在每次循环开始时都会被重新评估。如果条件为真，循环体就会执行；如果条件为假，循环就会结束。这种设计使得`while`循环非常适合处理那些需要根据动态条件来决定是否继续执行的情况。

**实际应用：猜数字游戏**
`while`循环在游戏开发中特别有用，比如实现一个猜数字游戏：

```rust
use std::io;

fn main() {
    let secret_number = 42;
    let mut attempts = 0;
    
    println!("猜一个1到100之间的数字！");
    
    while attempts < 10 {
        println!("请输入你的猜测（还剩{}次机会）：", 10 - attempts);
        
        let mut guess = String::new();
        io::stdin().read_line(&mut guess).expect("读取失败");
        let guess: i32 = guess.trim().parse().expect("请输入数字！");
        
        attempts = attempts + 1;
        
        if guess == secret_number {
            println!("恭喜！你猜对了！用了{}次", attempts);
            break;  // 跳出循环
        } else if guess < secret_number {
            println!("太小了！");
        } else {
            println!("太大了！");
        }
    }
    
    if attempts >= 10 {
        println!("游戏结束！正确答案是{}", secret_number);
    }
}
```

这个例子展示了`while`循环如何根据游戏状态来决定是否继续执行。循环会一直运行，直到玩家猜对数字或者用完所有机会为止。

#### 3. loop循环：无限循环的精确控制

`loop`循环会无限执行代码块，直到遇到`break`语句为止。这种循环特别适合那些需要持续运行，但退出条件在循环体内部的情况。

```rust
let mut count = 0;
loop {
    count = count + 1;
    if count > 5 {
        break;  // 跳出循环
    }
    println!("count = {}", count);
}
```

`loop`循环的优势在于它提供了最大的灵活性。你可以在循环体的任何位置使用`break`来退出循环，这使得它特别适合处理复杂的退出逻辑。

**实际应用：菜单选择系统**
`loop`循环在实现交互式菜单系统时非常有用：

```rust
use std::io;

fn main() {
    loop {
        println!("\n=== 计算器菜单 ===");
        println!("1. 加法");
        println!("2. 减法");
        println!("3. 乘法");
        println!("4. 除法");
        println!("0. 退出");
        println!("请选择操作：");
        
        let mut choice = String::new();
        io::stdin().read_line(&mut choice).expect("读取失败");
        let choice: i32 = choice.trim().parse().expect("请输入数字！");
        
        match choice {
            0 => {
                println!("再见！");
                break;  // 退出程序
            }
            1 => println!("你选择了加法"),
            2 => println!("你选择了减法"),
            3 => println!("你选择了乘法"),
            4 => println!("你选择了除法"),
            _ => println!("无效选择，请重试"),
        }
    }
}
```

这个例子展示了如何使用`loop`循环来实现一个持续运行的菜单系统。程序会一直显示菜单并等待用户输入，直到用户选择退出为止。

### 循环控制语句：精确控制循环行为

除了基本的循环结构，Rust还提供了两个重要的循环控制语句：`break`和`continue`。这些语句让我们能够精确控制循环的执行流程。

#### break语句：提前结束循环

`break`语句用于立即结束当前循环，无论循环条件是否仍然为真。这在需要提前退出循环的情况下非常有用。

```rust
for i in 1..=10 {
    if i == 5 {
        break;  // 当i等于5时跳出循环
    }
    println!("i = {}", i);
}
// 输出：1, 2, 3, 4
```

在这个例子中，循环原本应该执行10次，但当`i`等于5时，`break`语句会立即结束循环，导致只输出了前4个数字。

`break`语句在搜索算法中特别有用。例如，当我们在数组中查找某个元素时，一旦找到目标元素，就可以立即使用`break`退出循环，而不需要继续检查剩余的元素。

#### continue语句：跳过当前迭代

`continue`语句用于跳过当前循环迭代的剩余部分，直接开始下一次迭代。这在需要跳过某些特定情况时非常有用。

```rust
for i in 1..=10 {
    if i % 2 == 0 {
        continue;  // 跳过偶数
    }
    println!("奇数：{}", i);
}
// 输出：1, 3, 5, 7, 9
```

在这个例子中，`continue`语句使得程序跳过所有偶数，只输出奇数。`continue`语句在数据过滤和处理中非常有用，它允许我们轻松地跳过不需要处理的数据项。

### 循环标签：处理嵌套循环的精确控制

当程序中有嵌套循环时，`break`和`continue`语句默认只影响最内层的循环。但在某些情况下，我们可能需要跳出外层循环或者继续外层循环的下一次迭代。Rust的循环标签功能正是为这种情况设计的。

```rust
'outer: for i in 1..=3 {
    'inner: for j in 1..=3 {
        if i == 2 && j == 2 {
            break 'outer;  // 跳出外层循环
        }
        println!("i={}, j={}", i, j);
    }
}
```

在这个例子中，`'outer`和`'inner`是循环标签，它们用单引号标记。当`i`等于2且`j`等于2时，`break 'outer`语句会跳出标记为`'outer`的外层循环，而不是只跳出内层循环。

循环标签功能在处理复杂的嵌套循环时非常有用，它提供了精确的循环控制能力，使得程序逻辑更加清晰和可控。

### 与C语言的对比：理解Rust循环的设计优势

通过对比C语言和Rust的循环结构，我们可以更好地理解Rust语言的设计理念和优势。

**C语言的循环：**
```c
// for循环
for (int i = 1; i <= 5; i++) {
    printf("第%d次循环\n", i);
}

// while循环
int count = 0;
while (count < 5) {
    printf("count = %d\n", count);
    count++;
}

// do-while循环
int num = 0;
do {
    printf("num = %d\n", num);
    num++;
} while (num < 5);
```

**Rust的循环：**
```rust
// for循环
for i in 1..=5 {
    println!("第{}次循环", i);
}

// while循环
let mut count = 0;
while count < 5 {
    println!("count = {}", count);
    count = count + 1;
}

// loop循环（相当于while true）
let mut num = 0;
loop {
    println!("num = {}", num);
    num = num + 1;
    if num >= 5 {
        break;
    }
}
```

**主要区别和优势：**
Rust和C语言在循环方面有几个重要的区别。首先，Rust的`for`循环更加简洁和安全，不需要手动管理循环变量，也不容易出现数组越界的错误。其次，Rust没有`do-while`循环，但可以用`loop`循环来实现相同的功能，这种设计更加统一和一致。最后，Rust的循环控制更加安全，编译器会在编译时检查很多潜在的错误。

这些区别反映了Rust语言的设计哲学：强调安全性、简洁性和一致性。通过这些设计，Rust试图在保持高性能的同时，提供更好的开发体验和更少的运行时错误。

### 实际应用：批量数据处理

让我们通过一个实际的例子来展示循环在数据处理中的应用。这个例子将展示如何使用循环来处理多个学生的成绩数据。

```rust
fn main() {
    let scores = [85, 92, 78, 96, 88, 67, 91, 83];
    let mut total = 0;
    let mut count = 0;
    
    // 计算总分和人数
    for score in scores.iter() {
        total = total + score;
        count = count + 1;
    }
    
    // 计算平均分
    let average = total as f64 / count as f64;
    
    // 统计各等级人数
    let mut excellent = 0;  // 优秀（90分以上）
    let mut good = 0;       // 良好（80-89分）
    let mut pass = 0;       // 及格（60-79分）
    let mut fail = 0;       // 不及格（60分以下）
    
    for score in scores.iter() {
        if *score >= 90 {
            excellent = excellent + 1;
        } else if *score >= 80 {
            good = good + 1;
        } else if *score >= 60 {
            pass = pass + 1;
        } else {
            fail = fail + 1;
        }
    }
    
    println!("成绩统计：");
    println!("总分：{}", total);
    println!("平均分：{:.2}", average);
    println!("优秀：{}人", excellent);
    println!("良好：{}人", good);
    println!("及格：{}人", pass);
    println!("不及格：{}人", fail);
}
```

这个程序展示了如何使用循环来处理数组中的数据。第一个循环用于计算总分和统计人数，第二个循环用于根据成绩范围统计各等级的人数。通过循环，我们可以轻松地处理任意大小的数据集，而不需要为每个数据项编写重复的代码。

### 小结：循环结构的核心价值

循环结构是编程中不可或缺的控制流机制，它让程序从单次处理转变为批量处理，大大提高了程序的效率和实用性。通过`for`、`while`、`loop`等不同类型的循环，我们可以适应各种不同的使用场景，实现复杂的算法和数据处理逻辑。

Rust语言在循环设计方面提供了安全、简洁和一致的体验。`for`循环的安全遍历、`while`循环的条件控制、`loop`循环的灵活退出，以及循环标签的精确控制，都体现了Rust语言对安全性和表达能力的重视。

循环的应用范围非常广泛，从简单的数据遍历到复杂的算法实现，都离不开循环的支持。掌握循环的使用方法，是成为合格程序员的基本要求，也是编写高效软件的重要基础。通过合理使用循环，我们可以编写出既高效又可读的代码，实现复杂的业务逻辑和算法。

## 7.3 模式匹配：Rust的独特武器

**什么是模式匹配？**

模式匹配是Rust语言中最强大和最独特的特性之一，它让程序能够根据数据的"形状"或"特征"来做出精确的判断和处理。就像人类在面对复杂情况时会根据不同的特征来分类处理一样，程序也需要通过模式匹配来理解数据的结构和内容。

想象你在整理邮件系统：当收到一封邮件时，你需要根据邮件的特征来决定如何处理它。如果是工作邮件，你会将它放到工作文件夹；如果是朋友邮件，你会将它放到朋友文件夹；如果是垃圾邮件，你会直接删除；如果是重要邮件，你会标记为重要并优先处理。这种根据数据特征进行分类和处理的能力，就是模式匹配的核心思想。

模式匹配不仅仅是简单的条件判断，它是一种更加智能和精确的数据处理方式。它允许程序根据数据的类型、结构、内容等多个维度来做出决策，从而提供更加准确和高效的处理逻辑。

### 其他语言的限制：为什么需要更好的解决方案

在传统的编程语言中，我们通常使用`switch`语句来处理多个选择的情况。然而，这些传统的解决方案存在许多限制和问题，无法满足现代编程的需求。

**C语言switch的限制：**
```c
int day = 3;
switch (day) {
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n");
        break;
    case 3:
        printf("星期三\n");
        break;
    default:
        printf("其他日子\n");
        break;
}
```

C语言的`switch`语句存在几个严重的问题。首先，它只能匹配整数类型，无法处理字符串、浮点数或其他复杂的数据类型。其次，它容易出现"穿透"错误，即忘记写`break`语句导致意外执行下一个分支的代码。第三，它没有穷尽性检查，编译器不会提醒你遗漏了某些可能的情况。最后，它不能匹配复杂的数据结构，如结构体、联合体等。

**Java的switch也有类似问题：**
```java
int day = 3;
switch (day) {
    case 1:
        System.out.println("星期一");
        break;
    case 2:
        System.out.println("星期二");
        break;
    // 如果忘记写case 3，编译器不会提醒
    default:
        System.out.println("其他日子");
        break;
}
```

Java的`switch`语句虽然比C语言有所改进，但仍然存在一些问题。它仍然容易出现穿透错误，而且编译器不会强制检查所有可能的情况。这意味着程序员可能会遗漏某些重要的分支，导致程序在运行时出现意外行为。

### Rust的模式匹配：match语句的革命性设计

Rust的`match`语句彻底解决了传统`switch`语句的所有问题，提供了一种更加安全、强大和表达力强的模式匹配机制。

```rust
let day = 3;
match day {
    1 => println!("星期一"),
    2 => println!("星期二"),
    3 => println!("星期三"),
    4 => println!("星期四"),
    5 => println!("星期五"),
    6 => println!("星期六"),
    7 => println!("星期日"),
    _ => println!("无效的日期"),
}
```

**match语句的核心优势：**
`match`语句的设计体现了Rust语言对安全性和表达能力的重视。首先，它提供了穷尽性检查，编译器会确保所有可能的情况都被处理，这大大减少了运行时错误的可能性。其次，它支持表达式，可以返回值，这使得代码更加简洁和函数式。第三，它支持复杂的模式匹配，可以匹配各种数据结构和类型。最后，它不会出现穿透问题，每个分支都是独立的，不会意外执行下一个分支的代码。

### 穷尽性检查：编译器的智能保护

穷尽性检查是Rust模式匹配最重要的特性之一，它确保程序在所有可能的情况下都能正常工作。

**错误示例：**
```rust
let day = 3;
match day {
    1 => println!("星期一"),
    2 => println!("星期二"),
    3 => println!("星期三"),
    // 错误！编译器会提醒：non-exhaustive patterns
    // 需要处理其他所有可能的情况
}
```

当编译器发现`match`语句没有处理所有可能的情况时，它会报错并提醒程序员。这种编译时检查大大减少了运行时错误的可能性，提高了程序的可靠性。

**正确示例：**
```rust
let day = 3;
match day {
    1 => println!("星期一"),
    2 => println!("星期二"),
    3 => println!("星期三"),
    _ => println!("其他日子"),  // 处理所有其他情况
}
```

通过添加`_`分支，我们明确告诉编译器如何处理所有其他可能的情况。这种设计迫使程序员考虑所有可能的情况，确保程序的健壮性。

### match作为表达式：函数式编程的优雅

`match`语句不仅可以用来执行代码，还可以用来返回值，这使得它成为一种强大的表达式。

```rust
let day = 3;
let day_name = match day {
    1 => "星期一",
    2 => "星期二",
    3 => "星期三",
    4 => "星期四",
    5 => "星期五",
    6 => "星期六",
    7 => "星期日",
    _ => "无效的日期",
};

println!("今天是：{}", day_name);
```

这种设计使得代码更加简洁和表达力强。我们可以直接在变量赋值、函数返回等地方使用`match`表达式，而不需要先声明临时变量来存储中间结果。这种函数式的编程风格使得代码更加清晰和易于理解。

### 匹配复杂数据结构：模式匹配的强大能力

Rust的模式匹配真正强大的地方在于它能够处理复杂的数据结构，这是传统`switch`语句无法做到的。

#### 匹配元组：处理多维数据

元组是Rust中的一种复合数据类型，可以包含多个不同类型的值。模式匹配可以精确地匹配元组的结构和内容。

```rust
let point = (3, -7);
match point {
    (0, 0) => println!("在原点"),
    (0, y) => println!("在Y轴上，y = {}", y),
    (x, 0) => println!("在X轴上，x = {}", x),
    (x, y) => println!("在点({}, {})", x, y),
}
```

在这个例子中，模式匹配根据点的坐标位置来做出不同的处理。如果点在原点，输出"在原点"；如果点在Y轴上，输出Y坐标；如果点在X轴上，输出X坐标；如果点在其他位置，输出完整的坐标信息。这种精确的匹配能力使得程序能够根据数据的结构来做出智能的判断。

#### 匹配枚举：处理变体类型

枚举是Rust中表示变体类型的重要数据结构，模式匹配可以精确地匹配枚举的不同变体。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let msg = Message::Move { x: 10, y: 20 };

match msg {
    Message::Quit => println!("退出"),
    Message::Move { x, y } => println!("移动到({}, {})", x, y),
    Message::Write(text) => println!("写入：{}", text),
    Message::ChangeColor(r, g, b) => println!("改变颜色为RGB({}, {}, {})", r, g, b),
}
```

在这个例子中，我们定义了一个`Message`枚举，它包含四种不同的变体：`Quit`（退出）、`Move`（移动，包含x和y坐标）、`Write`（写入，包含文本内容）、`ChangeColor`（改变颜色，包含RGB值）。模式匹配可以精确地识别每种变体，并提取其中的数据。

这种能力使得Rust特别适合处理状态机、消息传递系统等需要处理多种不同数据类型的场景。通过模式匹配，我们可以安全地处理各种可能的情况，而不用担心遗漏某些重要的分支。

### 绑定和守卫：模式匹配的高级特性

Rust的模式匹配还提供了绑定和守卫功能，使得模式匹配更加灵活和强大。

#### 绑定：提取和重用数据

绑定允许我们在模式匹配中提取数据并将其绑定到变量，以便在后续的代码中使用。

```rust
let point = (3, -7);
match point {
    (x, y) if x == y => println!("在对角线上"),
    (x, y) if x == 0 => println!("在Y轴上，y = {}", y),
    (x, y) if y == 0 => println!("在X轴上，x = {}", x),
    (x, y) => println!("在点({}, {})", x, y),
}
```

在这个例子中，我们使用绑定来提取点的x和y坐标，然后在守卫条件中使用这些值。如果x等于y，说明点在对角线上；如果x等于0，说明点在Y轴上；如果y等于0，说明点在X轴上；否则，输出点的完整坐标。

#### 守卫：添加额外的条件

守卫允许我们在模式匹配中添加额外的条件，使得匹配更加精确。

```rust
let number = 4;
match number {
    n if n < 0 => println!("{}是负数", n),
    n if n > 0 => println!("{}是正数", n),
    _ => println!("是零"),
}
```

在这个例子中，我们使用守卫来检查数字的正负性。如果数字小于0，输出"是负数"；如果数字大于0，输出"是正数"；如果数字等于0，输出"是零"。守卫使得我们能够在模式匹配中添加复杂的逻辑条件。

### 简化模式匹配：if let和while let

虽然`match`语句非常强大，但在某些情况下可能会显得过于冗长。Rust提供了`if let`和`while let`来简化特定的模式匹配场景。

#### if let：简化单分支匹配

当只需要匹配一种情况时，`if let`比`match`更加简洁。

```rust
let some_value = Some(5);

// 使用match
match some_value {
    Some(x) => println!("值是：{}", x),
    None => {},
}

// 使用if let（更简洁）
if let Some(x) = some_value {
    println!("值是：{}", x);
}
```

`if let`语句专门用于处理只需要匹配一种模式的情况。它比`match`更加简洁，同时保持了模式匹配的安全性和表达能力。

#### while let：循环中的模式匹配

`while let`结合了循环和模式匹配，使得我们能够在循环中进行模式匹配。

```rust
let mut stack = Vec::new();
stack.push(1);
stack.push(2);
stack.push(3);

// 使用while let弹出所有元素
while let Some(top) = stack.pop() {
    println!("弹出：{}", top);
}
```

在这个例子中，`while let`语句会持续执行循环，直到`stack.pop()`返回`None`为止。每次循环时，如果`pop()`返回`Some(value)`，就会将值绑定到`top`变量并执行循环体；如果返回`None`，循环就会结束。

这种模式在迭代器、队列、栈等数据结构的处理中非常有用，它提供了一种优雅的方式来处理可能为空的数据。

### 实际应用：错误处理的优雅解决方案

模式匹配在错误处理中特别有用，它提供了一种优雅和安全的方式来处理各种可能的错误情况。

```rust
use std::fs::File;
use std::io::Read;

fn read_file_content(filename: &str) -> String {
    let mut file = match File::open(filename) {
        Ok(file) => file,
        Err(error) => {
            match error.kind() {
                std::io::ErrorKind::NotFound => {
                    panic!("文件{}不存在", filename);
                }
                std::io::ErrorKind::PermissionDenied => {
                    panic!("没有权限读取文件{}", filename);
                }
                _ => {
                    panic!("读取文件时发生未知错误：{:?}", error);
                }
            }
        }
    };

    let mut content = String::new();
    match file.read_to_string(&mut content) {
        Ok(_) => content,
        Err(error) => panic!("读取文件内容失败：{:?}", error),
    }
}
```

在这个例子中，我们使用模式匹配来处理文件操作中可能出现的各种错误。`File::open()`返回一个`Result`类型，我们使用`match`来检查操作是否成功。如果成功，我们获取文件句柄；如果失败，我们根据错误类型来提供不同的错误信息。

这种错误处理方式比传统的异常处理更加安全和明确。编译器会强制我们处理所有可能的错误情况，确保程序在任何情况下都能正常工作。

### 与C语言switch的对比：理解Rust的优势

通过对比C语言的`switch`语句和Rust的`match`语句，我们可以清楚地看到Rust模式匹配的优势。

| 特性 | C语言switch | Rust match | 优势说明 |
|------|-------------|------------|----------|
| 穷尽性检查 | ❌ 不检查 | ✅ 强制检查 | 编译时发现遗漏，减少运行时错误 |
| 返回值 | ❌ 不支持 | ✅ 支持 | 代码更简洁，函数式编程风格 |
| 复杂匹配 | ❌ 只支持整数 | ✅ 支持复杂数据结构 | 处理能力强，适用场景广泛 |
| 穿透问题 | ❌ 容易出错 | ✅ 不会穿透 | 避免意外错误，提高代码安全性 |
| 守卫条件 | ❌ 不支持 | ✅ 支持 | 添加复杂逻辑，匹配更精确 |

这些对比清楚地展示了Rust模式匹配的优越性。它不仅解决了传统`switch`语句的所有问题，还提供了更多强大的功能，使得程序更加安全、简洁和表达力强。

### 模式匹配解决的问题：从理论到实践

模式匹配不仅仅是一种语法特性，它解决了许多实际编程中的问题。

**1. 编译时错误检查：** 通过穷尽性检查，编译器能够在编译时发现潜在的错误，大大减少了运行时错误的可能性。这种提前发现问题的能力对于大型项目的开发非常重要。

**2. 代码安全性：** 模式匹配的精确性和安全性使得程序更加可靠。通过强制处理所有可能的情况，程序能够在各种输入下都能正常工作。

**3. 代码可读性：** 模式匹配的语法非常直观，使得代码的意图一目了然。相比嵌套的`if-else`语句，模式匹配更加清晰和易于理解。

**4. 性能优化：** 编译器可以优化模式匹配，使得生成的代码更加高效。在某些情况下，模式匹配的性能甚至比传统的`if-else`语句更好。

**5. 类型安全：** 模式匹配与Rust的类型系统紧密结合，确保类型安全。编译器会在编译时检查模式匹配的类型正确性。

### 实际应用：状态机的优雅实现

状态机是计算机科学中的一个重要概念，模式匹配使得状态机的实现变得非常优雅和清晰。

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

fn get_next_action(light: TrafficLight) -> &'static str {
    match light {
        TrafficLight::Red => "停车等待",
        TrafficLight::Yellow => "准备停车",
        TrafficLight::Green => "可以通行",
    }
}

fn main() {
    let light = TrafficLight::Red;
    println!("当前信号灯：{:?}", light);
    println!("应该：{}", get_next_action(light));
}
```

在这个例子中，我们使用枚举来表示交通信号灯的不同状态，使用模式匹配来根据当前状态决定应该采取的行动。这种实现方式非常清晰和易于扩展，如果需要添加新的状态，只需要在枚举中添加新的变体，并在`match`语句中添加相应的处理逻辑即可。

### 小结：模式匹配的革命性价值

模式匹配是Rust语言中最强大和最独特的特性之一，它彻底改变了我们处理复杂数据的方式。通过`match`语句，我们可以安全、简洁、高效地处理各种复杂的数据结构和业务逻辑。

Rust的模式匹配解决了传统编程语言中`switch`语句的所有问题，提供了穷尽性检查、表达式支持、复杂匹配、无穿透问题、守卫条件等强大功能。这些特性使得Rust特别适合处理复杂的业务逻辑、状态机、错误处理等场景。

模式匹配不仅仅是一种语法特性，它体现了Rust语言对安全性、简洁性和表达能力的重视。通过模式匹配，我们可以编写出更加安全、可靠和易于理解的代码，提高开发效率和代码质量。

掌握模式匹配的使用方法，是成为优秀Rust程序员的重要基础。它不仅能够帮助你编写更好的代码，还能够帮助你更好地理解Rust语言的设计哲学和编程范式。

## 7.4 实战练习

现在让我们通过实际项目来巩固学到的控制流知识。

### 练习1：简单计算器

**目标：** 综合运用条件语句和循环

**步骤：**
1. 创建新项目：`cargo new calculator`
2. 编写一个支持基本运算的计算器：

```rust
use std::io;

fn main() {
    loop {
        println!("\n=== 简单计算器 ===");
        println!("1. 加法");
        println!("2. 减法");
        println!("3. 乘法");
        println!("4. 除法");
        println!("0. 退出");
        println!("请选择操作：");
        
        let mut choice = String::new();
        io::stdin().read_line(&mut choice).expect("读取失败");
        let choice: i32 = choice.trim().parse().expect("请输入数字！");
        
        if choice == 0 {
            println!("再见！");
            break;
        }
        
        if choice < 1 || choice > 4 {
            println!("无效选择，请重试");
            continue;
        }
        
        println!("请输入第一个数字：");
        let mut num1 = String::new();
        io::stdin().read_line(&mut num1).expect("读取失败");
        let num1: f64 = num1.trim().parse().expect("请输入数字！");
        
        println!("请输入第二个数字：");
        let mut num2 = String::new();
        io::stdin().read_line(&mut num2).expect("读取失败");
        let num2: f64 = num2.trim().parse().expect("请输入数字！");
        
        let result = match choice {
            1 => num1 + num2,
            2 => num1 - num2,
            3 => num1 * num2,
            4 => {
                if num2 == 0.0 {
                    println!("错误：除数不能为零！");
                    continue;
                }
                num1 / num2
            }
            _ => continue,
        };
        
        println!("结果：{}", result);
    }
}
```

### 练习2：成绩等级判断

**目标：** 练习模式匹配和条件语句

**步骤：**
1. 创建新项目：`cargo new grade_system`
2. 编写成绩等级判断程序：

```rust
enum Grade {
    A,
    B,
    C,
    D,
    F,
}

fn get_grade(score: i32) -> Grade {
    match score {
        90..=100 => Grade::A,
        80..=89 => Grade::B,
        70..=79 => Grade::C,
        60..=69 => Grade::D,
        0..=59 => Grade::F,
        _ => Grade::F, // 处理负数或超过100的情况
    }
}

fn grade_to_string(grade: &Grade) -> &'static str {
    match grade {
        Grade::A => "优秀",
        Grade::B => "良好",
        Grade::C => "中等",
        Grade::D => "及格",
        Grade::F => "不及格",
    }
}

fn main() {
    let scores = [95, 87, 73, 65, 45, 102, -5];
    
    for score in scores.iter() {
        let grade = get_grade(*score);
        let grade_str = grade_to_string(&grade);
        
        if *score < 0 || *score > 100 {
            println!("成绩{}无效，等级：{}", score, grade_str);
        } else {
            println!("成绩{}，等级：{}", score, grade_str);
        }
    }
}
```

### 练习3：数字游戏

**目标：** 练习循环和条件判断

**步骤：**
1. 创建新项目：`cargo new number_game`
2. 编写猜数字游戏：

```rust
use std::io;
use std::cmp::Ordering;

fn main() {
    let secret_number = 42; // 可以改为随机数
    let mut attempts = 0;
    let max_attempts = 10;
    
    println!("欢迎来到猜数字游戏！");
    println!("我想了一个1到100之间的数字，你有{}次机会猜出来。", max_attempts);
    
    while attempts < max_attempts {
        attempts = attempts + 1;
        println!("\n第{}次尝试（还剩{}次）：", attempts, max_attempts - attempts);
        
        let mut guess = String::new();
        io::stdin().read_line(&mut guess).expect("读取失败");
        
        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("请输入有效的数字！");
                continue;
            }
        };
        
        if guess < 1 || guess > 100 {
            println!("请输入1到100之间的数字！");
            continue;
        }
        
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("太小了！"),
            Ordering::Greater => println!("太大了！"),
            Ordering::Equal => {
                println!("恭喜！你猜对了！用了{}次", attempts);
                return;
            }
        }
    }
    
    println!("游戏结束！正确答案是{}", secret_number);
}
```

### 练习4：学生成绩统计

**目标：** 综合运用所有控制流知识

**步骤：**
1. 创建新项目：`cargo new student_stats`
2. 编写学生成绩统计程序：

```rust
#[derive(Debug)]
struct Student {
    name: String,
    math: i32,
    english: i32,
    science: i32,
}

impl Student {
    fn new(name: &str, math: i32, english: i32, science: i32) -> Student {
        Student {
            name: name.to_string(),
            math,
            english,
            science,
        }
    }
    
    fn average(&self) -> f64 {
        (self.math + self.english + self.science) as f64 / 3.0
    }
    
    fn grade(&self) -> &'static str {
        let avg = self.average();
        match avg {
            avg if avg >= 90.0 => "A",
            avg if avg >= 80.0 => "B",
            avg if avg >= 70.0 => "C",
            avg if avg >= 60.0 => "D",
            _ => "F",
        }
    }
}

fn main() {
    let students = vec![
        Student::new("张三", 85, 92, 78),
        Student::new("李四", 92, 88, 95),
        Student::new("王五", 67, 73, 68),
        Student::new("赵六", 95, 98, 92),
        Student::new("钱七", 58, 62, 55),
    ];
    
    let mut total = 0;
    let mut count = 0;
    
    // 计算总分和人数
    for student in &students {
        total = total + student.math;
        total = total + student.english;
        total = total + student.science;
        count = count + 1;
    }
    
    // 计算平均分
    let average = total as f64 / count as f64;
    
    // 统计各等级人数
    let mut excellent = 0;  // 优秀（90分以上）
    let mut good = 0;       // 良好（80-89分）
    let mut pass = 0;       // 及格（60-79分）
    let mut fail = 0;       // 不及格（60分以下）
    
    for student in &students {
        let grade = student.grade();
        if grade == "A" {
            excellent = excellent + 1;
        } else if grade == "B" {
            good = good + 1;
        } else if grade == "C" {
            pass = pass + 1;
        } else {
            fail = fail + 1;
        }
    }
    
    println!("=== 学生成绩统计 ===");
    println!("总人数：{}", students.len());
    println!("平均分：{:.2}", average);
    println!("优秀：{}人", excellent);
    println!("良好：{}人", good);
    println!("及格：{}人", pass);
    println!("不及格：{}人", fail);
}
```

### 练习提示

- 如果遇到编译错误，仔细阅读错误信息
- 可以尝试修改代码，看看结果会有什么变化
- 模式匹配的穷尽性检查是Rust的安全特性，要习惯它
- 多使用`match`而不是嵌套的`if-else`

## 7.5 小结与思考

恭喜你！你已经掌握了Rust的流程控制，这是编程中的核心概念。让我们来总结一下这一章学到的内容：

### 本章要点总结

**1. 条件语句让程序"思考"**
- `if`、`else`、`else if` 让程序根据条件做出选择
- Rust的`if`可以作为表达式使用，返回值
- 条件必须是布尔值，不能是数字

**2. 循环让程序"重复"**
- `for`循环：遍历范围或集合，最常用
- `while`循环：条件为真时重复执行
- `loop`循环：无限循环，需要手动跳出
- `break`和`continue`控制循环流程

**3. 模式匹配让程序"智能"**
- `match`语句：强大的模式匹配，有穷尽性检查
- `if let`：简化单分支模式匹配
- `while let`：循环中的模式匹配
- 支持复杂数据结构的匹配

### 与C语言的主要区别

| 特性 | C语言 | Rust | 优势 |
|------|-------|------|------|
| 条件语句 | if/else | if/else | Rust支持if表达式 |
| 循环 | for/while/do-while | for/while/loop | Rust的for更安全 |
| 多路分支 | switch | match | 穷尽性检查，更安全 |
| 类型检查 | 运行时 | 编译时 | 提前发现错误 |

### 思考题

**初级思考：**
1. 为什么Rust的`if`可以作为表达式使用？这样设计有什么好处？
2. 你能举出生活中哪些场景可以用循环来模拟吗？

**中级思考：**
3. 模式匹配的穷尽性检查为什么重要？它能防止什么错误？
4. 什么时候应该使用`match`，什么时候应该使用`if let`？

**高级思考：**
5. 如果让你设计一个状态机（比如自动售货机），你会如何使用模式匹配？
6. Rust的模式匹配相比其他语言的switch语句，在性能上有什么优势？
