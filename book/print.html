<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>New for Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">New for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="本书介绍"><a class="header" href="#本书介绍">本书介绍</a></h1>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="./ch0.html">为什么是这本书</a></li>
<li><a href="./ch1.html">Rust语言背景与发展</a></li>
<li><a href="./ch2.html">学习Rust的计算机基础</a></li>
<li><a href="copyright.html">版权声明</a></li>
</ul>
<h2 id="为什么要有这本书"><a class="header" href="#为什么要有这本书">为什么要有这本书？</a></h2>
<p>很多人觉得 Rust 难学，第一反应是"这门语言语法太怪了""所有权、生命周期太抽象了"，但实际上，<strong>大部分人学不会 Rust，并不是因为 Rust 本身有多难，而是因为缺乏计算机基础知识</strong>。</p>
<p>在实际教学和企业培训中，我们发现：</p>
<ul>
<li>很多同学虽然学过 C 语言，但对内存、进程、线程、文件系统、编译原理等底层知识并不扎实。</li>
<li>一旦遇到 Rust 的所有权、借用、并发安全等设计理念，就会觉得"无从下手"，其实是因为底层原理没打好基础。</li>
<li>很多 Rust 的"难点"，其实是现代系统编程的通用难点，只不过 Rust 让你必须正视它们。</li>
</ul>
<p><strong>本书的最大特色，就是在 Rust 学习过程中，穿插讲解计算机基础知识，也就是"内力"。</strong></p>
<p>你不仅能学到 Rust 的语法和工程实践，还能系统梳理计算机组成、内存管理、操作系统、并发原理等底层知识。
很多 Rust 的设计点，都会结合其他语言（更多是C/C++）和底层原理对比讲解，帮助你建立"迁移思维"。
这样学 Rust，不仅能写出高质量代码，更能打下坚实的计算机基础，为后续学习任何系统级开发打好底子。</p>
<p><strong>适合人群：</strong></p>
<ul>
<li>有 C 语言基础，但对底层原理不熟悉的开发者</li>
<li>希望补齐"内力"，真正理解现代编程语言设计的同学</li>
<li>想在企业、团队中推动高质量开发和工程实践的工程师</li>
</ul>
<blockquote>
<p>这本书不是单纯教你 Rust 语法，而是带你"内外兼修"，让你在学 Rust 的同时，补齐计算机基础，提升底层功力，成为真正的现代系统开发者。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章rust语言背景与发展"><a class="header" href="#第一章rust语言背景与发展">第一章：Rust语言背景与发展</a></h1>
<h2 id="11-计算机语言发展简史"><a class="header" href="#11-计算机语言发展简史">1.1 计算机语言发展简史</a></h2>
<p>在正式学习Rust之前，我们先来回顾一下计算机编程语言的发展历程。C语言自1972年诞生以来，凭借其高效、灵活和接近底层的特性，成为了系统级开发的事实标准。此后，C++、Java、Python、Go等语言相继出现，各自针对不同的应用场景和开发需求进行了优化。</p>
<p>然而，随着软件系统的复杂度不断提升，传统语言在安全性、并发性和可维护性方面逐渐暴露出一些问题。例如，C/C++容易出现内存泄漏、野指针、数据竞争等难以排查的bug。为了解决这些问题，Rust应运而生。</p>
<h2 id="12-rust的诞生背景与设计目标"><a class="header" href="#12-rust的诞生背景与设计目标">1.2 Rust的诞生背景与设计目标</a></h2>
<p>Rust最初由Mozilla工程师Graydon Hoare于2010年发起，目标是打造一种既能像C/C++一样高效，又能最大程度保证安全性的系统级编程语言。Rust的核心设计理念包括：</p>
<ul>
<li>
<p><strong>内存安全</strong>：指的是程序不会出现"野指针"、"悬垂引用"或"内存泄漏"等问题。可以理解为你租了一间房子，钥匙只在你手里，搬走时房东会自动收回钥匙，别人无法再进来捣乱。Rust通过所有权（Ownership）和借用（Borrowing）机制，保证每一块内存都有明确的"主人"，用完就自动归还，防止"房子没人管"或"钥匙乱传"导致的混乱。</p>
<ul>
<li>许多传统语言（如C、C++）没有内存安全机制，开发者需要手动管理内存，容易出现野指针、内存泄漏等问题。Java、Python等虽然有垃圾回收（GC），但仍可能因引用遗留等原因出现内存泄漏。</li>
</ul>
</li>
<li>
<p><strong>并发安全</strong>：并发是指多个任务（比如多个线程）同时运行。并发安全意味着不会因为多个线程同时操作同一份数据而出错。就像几个人同时往同一个快递箱里放东西，如果没有规则，可能会把东西弄丢或打架。Rust在编译阶段就会检查你的代码，确保不会出现"数据竞争"，即不会有两个线程同时修改同一份数据，避免了多线程下常见的隐蔽bug。</p>
<ul>
<li>C、C++等语言的并发安全主要靠开发者自觉和手动加锁，编译器无法帮你发现数据竞争。Java、Python等虽然有线程机制，但也无法在编译期彻底防止并发bug。</li>
</ul>
</li>
<li>
<p><strong>高性能</strong>：Rust追求和C/C++一样的运行效率。所谓"零成本抽象"，就是你用高级语法写的代码，编译后和手写底层代码一样快，没有额外的性能损耗。比如你用for循环、迭代器等高级写法，编译器会自动优化成最快的机器码，既易写易读，又不牺牲速度。</p>
<ul>
<li>一些高级语言（如Python、JavaScript）虽然易用，但由于解释执行或虚拟机机制，运行效率远低于C、C++和Rust。C++虽然高效，但有些高级特性（如虚函数、多态）会带来一定的性能开销。</li>
</ul>
</li>
<li>
<p><strong>现代化工具链</strong>：Rust自带一整套开发工具，比如包管理（cargo）、自动化测试、文档生成、代码格式化等。就像买了一台新电脑，系统和常用软件都帮你装好了，不用再到处找驱动、装插件。这样可以大大提升开发效率，团队协作也更方便。</p>
<ul>
<li>许多老牌语言（如C、C++）缺乏统一的官方工具链，包管理、构建、测试等需要依赖第三方工具，配置繁琐。Python、Java等虽然有包管理工具，但集成度和一致性不如Rust的cargo。</li>
</ul>
</li>
</ul>
<h2 id="13-rust与cc的对比"><a class="header" href="#13-rust与cc的对比">1.3 Rust与C/C++的对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>C/C++</th><th>Rust</th></tr></thead><tbody>
<tr><td>内存管理</td><td>手动/RAII</td><td>所有权+借用+生命周期</td></tr>
<tr><td>并发安全</td><td>需开发者自行保证</td><td>编译器静态检查，防止数据竞争</td></tr>
<tr><td>错误处理</td><td>返回码/异常</td><td>Result/Option类型</td></tr>
<tr><td>包管理</td><td>无统一标准</td><td>cargo一站式解决</td></tr>
<tr><td>生态</td><td>成熟，历史悠久</td><td>新兴，发展迅速</td></tr>
</tbody></table>
</div>
<p>Rust并不是要取代C/C++，而是为系统级开发提供一种更安全、更现代的选择。</p>
<h2 id="14-rust的实际应用与生态"><a class="header" href="#14-rust的实际应用与生态">1.4 Rust的实际应用与生态</a></h2>
<p>Rust不仅在技术圈内备受推崇，近年来更是上升到国家战略层面。2024年，美国拜登政府发布政策，<strong>明确推动在关键基础设施和政府软件项目中采用Rust语言，理由是Rust能有效防止内存安全漏洞，提升国家网络安全水平</strong>。这一政策被多家主流媒体和安全专家解读为"软件安全领域的里程碑"。</p>
<p>Rust的影响力远不止于此：</p>
<ul>
<li><strong>工业界广泛应用</strong>：微软、亚马逊、谷歌、Meta（Facebook）、Cloudflare等科技巨头都在核心产品中引入Rust。例如，微软在Windows底层组件中逐步用Rust替换C/C++，以减少安全漏洞；亚马逊的云服务（AWS）也有大量Rust代码。</li>
<li><strong>开源社区活跃</strong>：Rust连续多年被Stack Overflow评为"最受欢迎的编程语言"，社区贡献者众多，生态繁荣。参考：<a href="https://survey.stackoverflow.co/2024/technology#admired-and-desired-language-desire-admire">https://survey.stackoverflow.co/2024/technology#admired-and-desired-language-desire-admire</a></li>
<li><strong>安全与高性能并重</strong>：Rust被广泛用于浏览器引擎（如Firefox的Servo）、区块链、嵌入式、物联网、Web后端等领域，尤其适合对安全性和性能要求极高的场景。</li>
<li><strong>政策推动与标准化</strong>：除了美国，欧盟、日本等也在推动关键基础设施采用更安全的系统级语言，Rust成为首选之一。</li>
<li><strong>中国科技巨头积极采用</strong>：阿里巴巴、字节跳动、腾讯、华为等国内大型互联网公司也在核心系统、云计算、数据库、区块链等领域积极引入Rust。例如，阿里巴巴在云原生基础设施和高性能服务中使用Rust提升安全性和并发性能；字节跳动在推荐系统、分布式存储等场景采用Rust重构关键模块；腾讯和华为也在操作系统、物联网等项目中推动Rust的落地。越来越多的中国初创公司和开源社区也在拥抱Rust，推动其在国内生态的繁荣发展。</li>
</ul>
<p>这些趋势表明，Rust不仅是技术创新的代表，更是全球软件安全和基础设施现代化的重要推动力。学习Rust，不仅能提升个人技术竞争力，也有助于把握未来行业发展的脉搏。</p>
<h2 id="15-安装rust开发环境"><a class="header" href="#15-安装rust开发环境">1.5 安装Rust开发环境</a></h2>
<p>下面我们来动手安装Rust开发环境，并编写第一个Rust程序。</p>
<h3 id="151-安装rust"><a class="header" href="#151-安装rust">1.5.1 安装Rust</a></h3>
<p>在Linux/macOS终端或Windows的WSL中，执行以下命令：</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>根据提示完成安装后，重启终端，输入：</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<p>如果能看到版本号，说明安装成功。</p>
<h3 id="152-配置vscode插件"><a class="header" href="#152-配置vscode插件">1.5.2 配置VSCode插件</a></h3>
<p>推荐安装"rust-analyzer"插件，获得更好的代码补全和语法提示体验。</p>
<h3 id="153-创建第一个rust项目"><a class="header" href="#153-创建第一个rust项目">1.5.3 创建第一个Rust项目</a></h3>
<p>使用cargo新建项目：</p>
<pre><code class="language-bash">cargo new hello_rust
cd hello_rust
cargo run
</code></pre>
<p>你会看到输出：</p>
<pre><code>Hello, world!
</code></pre>
<h4 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h4>
<p><code>src/main.rs</code> 文件内容如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>是不是很熟悉？和C语言的<code>printf</code>类似，但Rust的<code>println!</code>是一个宏，后续我们会详细讲解。</p>
<h2 id="16-小结与思考题"><a class="header" href="#16-小结与思考题">1.6 小结与思考题</a></h2>
<p>本章我们回顾了编程语言的发展，了解了Rust的诞生背景、设计目标和核心优势，并完成了开发环境的安装和第一个程序的编写。Rust以其独特的安全性和高性能，正在成为越来越多企业的首选。</p>
<h3 id="思考题"><a class="header" href="#思考题">思考题</a></h3>
<ol>
<li>你认为C语言在现代开发中最大的优势和劣势分别是什么？</li>
<li>Rust的所有权机制能解决哪些C语言常见的bug？</li>
<li>试着用C语言写一个"Hello, world!"程序，并与Rust的版本进行对比，有哪些异同？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章计算机基础与rust定位"><a class="header" href="#第二章计算机基础与rust定位">第二章：计算机基础与Rust定位</a></h1>
<p>对于一些小白来说，第一章我们操作的安装Rust的操作，其实是一知半解的。Rust是一个编程语言 or 软件 or 什么别的？ <code>cargo</code>又是什么东西。其实在学习编程的时候，很多人都是被这些底层的原理给吓跑了，因为在学校的时候，我们只是按照书本上的内容进行操作，进行配置环境，但是问到这是怎么运行的，就会说："我不道啊，都是老师教的。"这一章就是用来补齐一些计算机基础，从第一步开始就<strong>稳扎稳打、注重内力</strong>，这不仅对学习Rust有帮助，这是学习任何计算机相关的知识的基础。本章会有非常多的反复的类比，旨在形象地强化一些概念。</p>
<h2 id="21-计算机系统的基本组成"><a class="header" href="#21-计算机系统的基本组成">2.1 计算机系统的基本组成</a></h2>
<p>计算机系统主要由<em>硬件</em>和<em>软件</em>两大部分组成，二者密不可分：</p>
<ul>
<li><strong>硬件</strong>：计算机的"躯壳"，包括CPU（中央处理器）、内存（RAM）、硬盘（存储）、输入输出设备（如键盘、鼠标、显示器等）。</li>
<li><strong>软件</strong>：计算机的"灵魂"，包括操作系统（如Windows、Linux、macOS）和各种应用程序（如微信、浏览器、游戏等）。软件通过一系列指令控制硬件完成各种任务。</li>
</ul>
<p>也可以用厨房来比喻：</p>
<ul>
<li><strong>CPU</strong> 就像厨师，负责思考和做菜（处理数据和指令）。</li>
<li><strong>内存</strong> 就像操作台，厨师把正在做的菜和用到的食材都放在这里，方便随时拿取。</li>
<li><strong>硬盘</strong> 就像储藏室，存放大量还没用到的食材和工具，需要时再拿出来。</li>
<li><strong>输入设备</strong>（如键盘、鼠标）就像点菜的顾客或送菜的服务员，把需求和信息传递给厨师。</li>
<li><strong>输出设备</strong>（如显示器、打印机）就像上菜窗口，把做好的菜端给顾客。</li>
<li><strong>软件</strong> 就像菜谱和餐厅的规则，指导厨师和服务员如何协作。</li>
</ul>
<p>整个厨房高效运作，离不开每个环节的协作，这就像计算机硬件和软件的分工一样。</p>
<h3 id="思考与解释"><a class="header" href="#思考与解释">思考与解释：</a></h3>
<ul>
<li><strong>为什么内存比硬盘小很多，但速度快很多？</strong>
<ul>
<li>类比：
<ul>
<li>操作台（内存）空间有限，但厨师可以非常快地拿取和处理。</li>
<li>储藏室（硬盘）空间大，但每次取用都要走一趟，速度慢得多。</li>
</ul>
</li>
<li>内存技术快但贵，硬盘容量大但慢。</li>
</ul>
</li>
<li><strong>为什么不能把所有东西都放在内存？</strong>
<ul>
<li>操作台太大既贵又占地方，很多食材暂时用不到，放在储藏室更合适。</li>
</ul>
</li>
<li><strong>为什么程序运行时要"加载"到内存？</strong>
<ul>
<li>就像厨师做菜前要把食材从储藏室拿到操作台，程序运行前也要把数据和指令从硬盘搬到内存，CPU才能高效处理。</li>
</ul>
</li>
</ul>
<h2 id="22-软件是如何运行的"><a class="header" href="#22-软件是如何运行的">2.2 软件是如何运行的</a></h2>
<h3 id="221-编程语言和编译器"><a class="header" href="#221-编程语言和编译器">2.2.1 编程语言和编译器</a></h3>
<p>计算机只能识别0和1（二进制），所有数据和指令最终都要转成0/1（二进制文件）。十六进制常用于表示内存地址和数据，便于阅读和调试。
而人类能理解的语言是自然语言，例如英语。所以如何让计算机理解人类的指令是很关键的。</p>
<p>**而自然语言是有歧义的。**例如：这个人的头发长得奇怪。究竟是头发长度长的奇怪，还是头发的形状看起来奇怪？
那么，我们就需要一种人类能够理解的，能够翻译成0和1二进制代码的，无二义性的东西，作为人和计算机之间的桥梁。</p>
<p><strong>高级编程语言</strong>应运而生。而从人类编写的高级编程语言到机器能懂的二进制语言之间，需要一个翻译器 —— <strong>编译器（解释器）</strong></p>
<ul>
<li><strong>编译器</strong>：一种特殊的软件工具（"翻译器"），能把我们写的"高级语言"代码（如C、Rust）一次性翻译成计算机能直接执行的"机器码"，生成可执行文件，运行速度快。</li>
<li><strong>解释器</strong>：像"翻译员"，每次运行时逐行翻译代码，边翻译边执行，灵活但速度慢（如Python、JavaScript）。</li>
</ul>
<p>为什么会有两种不同的翻译器呢？其实，这和不同的需求和历史发展有关：</p>
<ul>
<li>
<p><strong>编译器</strong>（如C、Rust）：</p>
<ul>
<li>优点：一次性把全部代码翻译成机器码，生成可执行文件，运行速度快，适合对性能要求高的场景。</li>
<li>缺点：每次修改代码都要重新编译，开发调试周期稍长。</li>
<li>适用场景：操作系统、游戏、服务器等需要高性能的程序。</li>
<li>类比：像把一本英文小说全部翻译成中文再出版，读者可以直接看中文版，阅读体验流畅。</li>
</ul>
</li>
<li>
<p><strong>解释器</strong>（如Python、JavaScript）：</p>
<ul>
<li>优点：可以边写边运行，修改一行代码马上看到效果，开发效率高，适合快速试验和学习。</li>
<li>缺点：每次运行都要"翻译"一遍，速度慢一些。</li>
<li>适用场景：脚本、自动化、数据分析、网页前端等对性能要求不高、但开发灵活性要求高的场合。</li>
<li>类比：像有个翻译员在你身边，每读一句英文就翻译一句中文，虽然灵活但速度慢。</li>
</ul>
</li>
</ul>
<p><strong>历史背景</strong>：早期计算机资源有限，大家更关注运行效率，所以C、C++等编译型语言流行。随着计算机变快，开发效率变得更重要，解释型语言（如Python）开始流行，适合快速开发和原型设计。</p>
<p>我们在第一章安装的软件里面，其中一个很关键的就是编译器。Rust的编译器叫做rustc，而c、c++的编译器主流是gcc、g++、clang、clang++等。</p>
<h3 id="222-程序的运行流程"><a class="header" href="#222-程序的运行流程">2.2.2 程序的运行流程</a></h3>
<p>程序的运行大致分为以下几个步骤：</p>
<ol>
<li><strong>编写代码（高级语言）</strong>。开发者使用如Rust、C、Python等高级编程语言编写源代码。</li>
<li><strong>编译/解释生成二进制文件</strong>。源代码通过编译器（如rustc、gcc）或解释器（如python）被翻译成计算机能直接执行的机器码（二进制指令）。编译型语言会生成可执行文件，解释型语言则在运行时逐行翻译执行。</li>
<li><strong>存入硬盘</strong>。编译生成的可执行二进制文件或脚本文件被保存到硬盘等存储介质中。</li>
<li><strong>操作系统加载到内存</strong>。当用户运行程序时，操作系统会将可执行文件从硬盘加载到内存。只有在内存中的程序才能被CPU访问和执行。</li>
<li><strong>CPU执行指令</strong>。CPU从内存中读取指令，逐条执行，实现程序的功能。</li>
</ol>
<p>简而言之：代码经过编译/解释后生成二进制文件，存储在硬盘，运行时由操作系统加载到内存，最终由CPU执行。</p>
<h2 id="23-操作系统基础"><a class="header" href="#23-操作系统基础">2.3 操作系统基础</a></h2>
<p>操作系统（Operating System, OS）是管理和协调计算机硬件与软件资源的核心系统软件。</p>
<blockquote>
<p>例子：Windows、Linux、macOS、Android</p>
</blockquote>
<p>直观来看，操作系统就是给我们提供用户界面的一个东西，方便我们操作。
但实际上，并不是这样，图形用户界面（GUI）只是操作系统很小的一部分！</p>
<h3 id="操作系统到底是什么"><a class="header" href="#操作系统到底是什么">操作系统到底是什么？</a></h3>
<p>这里是一个主板，有非常复杂的硬件：
<img src="./assets/cpu.png" alt="主板" /></p>
<p>如果没有操作系统，每个我们编写的程序都必须自己负责：
如何让CPU执行自己的指令；
如何分配和管理内存；
如何读写硬盘、显示内容、响应键盘鼠标等外设；
如何和其他程序"和平共处"，避免互相干扰。
这会让每个程序都变得极其复杂，而且容易出错，甚至会导致系统崩溃或数据丢失。</p>
<p>操作系统的作用就是：</p>
<ul>
<li>统一管理和调度硬件资源，简化程序开发；</li>
<li>让多个程序可以安全、稳定地同时运行，互不干扰；</li>
<li>提供标准的接口和服务（如文件系统、网络、图形界面等），让开发者专注于自己的业务逻辑。</li>
</ul>
<p>有了操作系统，开发者只需要关心"做什么"，而不必关心"怎么和硬件打交道"，大大提升了开发效率和系统安全性。</p>
<p>在程序运行过程中，操作系统负责下面的工作：</p>
<ul>
<li>把程序从硬盘加载到内存；</li>
<li>分配CPU资源让程序执行；</li>
<li>管理程序运行时产生的数据和文件；</li>
<li>处理输入输出（如键盘、鼠标、网络等）。</li>
</ul>
<p>这样我们编写的程序只需要调用下面这样的接口就好了。</p>
<p>对于c语言：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE *fp = fopen("test.txt", "w"); // 打开文件，写入模式
    if (fp == NULL) {
        printf("无法打开文件\n");
        return 1;
    }
    fprintf(fp, "Hello, world!\n"); // 写入内容
    fclose(fp); // 关闭文件
    return 0;
}
</code></pre>
<p>对于Rust：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Write;

fn main() {
    let mut file = File::create("test.txt").expect("无法创建文件");
    file.write_all(b"Hello, world!\n").expect("写入失败");
}
</code></pre></pre>
<p>否则，我们就要手动用代码操纵磁盘，来读取，这是非常痛苦且低效的！！！
简而言之，操作系统是所有程序运行的"总管"，没有操作系统，绝大多数应用程序都无法独立运行。
操作系统为我们提供了很多接口，用于管理和控制硬件，下面我会以C和Rust的例子来阐释。</p>
<h3 id="进程与线程并发与并行"><a class="header" href="#进程与线程并发与并行">进程与线程、并发与并行</a></h3>
<p>在现代操作系统中，<strong>进程</strong>和<strong>线程</strong>是实现多任务的两种基本单位。</p>
<ul>
<li>
<p><strong>进程</strong>：可以理解为正在运行的一个"程序实例"。比如你同时开着微信和浏览器，这就是两个进程。每个进程有自己独立的内存空间，互不干扰。</p>
<ul>
<li>类比：进程就像一栋大楼里的不同公司，各自有自己的办公室和员工，互不打扰。</li>
</ul>
</li>
<li>
<p><strong>线程</strong>：是进程内部的"执行小分队"，一个进程可以有多个线程同时工作。比如浏览器可以一边加载网页一边播放音乐，这通常是不同线程在协作。</p>
<ul>
<li>类比：线程就像公司里的不同部门，大家在同一个办公室里协作完成不同任务。</li>
</ul>
</li>
</ul>
<h4 id="并发与并行"><a class="header" href="#并发与并行">并发与并行</a></h4>
<ul>
<li><strong>并发</strong>：指的是多个任务"轮流"执行，看起来像同时进行（比如单核CPU下的多任务切换）。
<ul>
<li>类比：一个厨师轮流炒几道菜，虽然只有一口锅，但切换得快，顾客感觉每道菜都在做。</li>
</ul>
</li>
<li><strong>并行</strong>：指的是多个任务"真正"同时进行（比如多核CPU下，每个核各干一件事）。
<ul>
<li>类比：几位厨师各自炒一道菜，真正同时出锅，效率更高。</li>
</ul>
</li>
</ul>
<h4 id="为什么要有进程和线程"><a class="header" href="#为什么要有进程和线程">为什么要有进程和线程？</a></h4>
<p>有了操作系统，我们只需要用简单的接口就能让程序"多线程"运行，无需自己管理底层的CPU调度和资源分配。</p>
<h4 id="代码示例-1"><a class="header" href="#代码示例-1">代码示例</a></h4>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
void* thread_func(void* arg) {
    // 线程要做的事情
}
int main() {
    pthread_t tid;
    pthread_create(&amp;tid, NULL, thread_func, NULL); // 创建线程
    pthread_join(tid, NULL); // 等待线程结束
    return 0;
}
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        // 线程要做的事情
    });
    handle.join().unwrap(); // 等待线程结束
}</code></pre></pre>
<blockquote>
<p>只需几行代码，就能让程序同时做多件事。底层的线程调度、资源分配都由操作系统负责，开发者不用操心。</p>
</blockquote>
<h4 id="小结"><a class="header" href="#小结">小结</a></h4>
<ul>
<li>进程和线程让程序能"同时"做多件事，提升效率和响应速度。</li>
<li>并发和并行是实现多任务的两种方式，操作系统会根据硬件自动安排。</li>
<li>C和Rust都提供了标准接口，开发者只需调用，无需关心底层细节。</li>
</ul>
<h3 id="变量内存与地址"><a class="header" href="#变量内存与地址">变量、内存与地址</a></h3>
<p>我们只需声明变量，系统自动分配内存。需要获取地址时，也有标准写法。</p>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">int a = 10; //底层是编程语言操作操作系统在内存里开辟一块新区域
int* p = &amp;a; // 获取变量a在内存里的地址
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10;
let p = &amp;a; // 获取变量a的引用
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>不用关心内存的具体分配细节，操作系统和语言帮我们管理好。</p>
</blockquote>
<h3 id="文件与文件系统"><a class="header" href="#文件与文件系统">文件与文件系统</a></h3>
<p>如前所述，读写文件只需调用标准接口。</p>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">fopen("test.txt", "w"); // 打开文件
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>File::create("test.txt"); // 创建文件
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>不用自己操作磁盘硬件，操作系统帮我们完成所有底层工作。</p>
</blockquote>
<hr />
<h2 id="24-程序的编译与执行流程"><a class="header" href="#24-程序的编译与执行流程">2.4 程序的编译与执行流程</a></h2>
<p>我们平时写的代码（无论是C还是Rust），其实只是"说明书"或者"菜谱"，计算机本身是看不懂的。要让计算机真正执行你的指令，需要经过一系列"翻译"和"加工"过程。</p>
<h3 id="241-从代码到程序像工厂生产商品"><a class="header" href="#241-从代码到程序像工厂生产商品">2.4.1 从代码到程序：像工厂生产商品</a></h3>
<p>可以把整个过程想象成工厂生产商品：</p>
<ol>
<li>
<p><strong>编写源代码</strong><br />
你写的C或Rust代码，就像是产品的设计图纸。</p>
</li>
<li>
<p><strong>编译/翻译</strong><br />
编译器（如gcc、rustc）就像工厂的翻译和加工机器，把你的设计图纸翻译成零件（机器码/目标文件）。</p>
</li>
<li>
<p><strong>链接/组装</strong><br />
链接器把所有零件（目标文件、库文件）组装成一个完整的产品（可执行文件）。</p>
</li>
<li>
<p><strong>运行/交付</strong><br />
操作系统像物流，把产品送到用户手中（把程序加载到内存，交给CPU执行）。</p>
</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>阶段</th><th>C语言</th><th>Rust语言</th></tr></thead><tbody>
<tr><td>编译</td><td>gcc main.c -o main</td><td>rustc main.rs</td></tr>
<tr><td>运行</td><td>./main</td><td>./main</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>小结</strong>：你只需要写好"说明书"，剩下的翻译、组装、交付都由编译器和操作系统帮你搞定。</p>
</blockquote>
<hr />
<h3 id="242-静态类型与动态类型"><a class="header" href="#242-静态类型与动态类型">2.4.2 静态类型与动态类型</a></h3>
<ul>
<li><strong>静态类型</strong>（如C、Rust）：变量的类型在编译时就确定了，出错能早发现，运行更快。</li>
<li><strong>动态类型</strong>（如Python、JavaScript）：变量类型在运行时才确定，写起来灵活，但容易出错。</li>
</ul>
<p><strong>对比示例：</strong></p>
<p>C/Rust（静态类型）：</p>
<pre><code class="language-c">int a = 10; // a只能是整数
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: i32 = 10; // a只能是整数
<span class="boring">}</span></code></pre></pre>
<p>Python（动态类型）：</p>
<pre><code class="language-python">a = 10
a = "hello" # 也可以变成字符串
</code></pre>
<blockquote>
<p>Rust和C一样，属于静态类型语言，但Rust支持类型推断，代码更简洁。</p>
</blockquote>
<hr />
<h3 id="243-内存管理方式的演变"><a class="header" href="#243-内存管理方式的演变">2.4.3 内存管理方式的演变</a></h3>
<p>在C语言中，内存管理完全靠开发者自己，容易出错：</p>
<pre><code class="language-c">int* p = (int*)malloc(sizeof(int)); // 手动分配内存
*p = 42;
free(p); // 手动释放内存，忘了就会泄漏
</code></pre>
<p><strong>常见问题：</strong></p>
<ul>
<li><strong>野指针</strong>：指向已经被释放或未初始化的内存，操作会导致崩溃或安全漏洞。</li>
<li><strong>内存泄漏</strong>：分配了内存但忘记释放，程序越跑越慢，最终崩溃。</li>
</ul>
<p>Rust的做法更安全：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = Box::new(42); // 自动分配和释放内存
    // x在这里有效
} // 这里x自动释放，之后无法再访问x
// println!("{}", x); // 编译报错：x已被释放
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Rust通过所有权和生命周期机制，自动管理内存，极大降低了野指针和内存泄漏的风险。</p>
</blockquote>
<hr />
<h3 id="244-栈与堆的基础知识"><a class="header" href="#244-栈与堆的基础知识">2.4.4 栈与堆的基础知识</a></h3>
<ul>
<li><strong>栈</strong>：像快递员送快递，先进后出，速度快，但空间有限。</li>
<li><strong>堆</strong>：像仓库，随时存取，但需要自己记得取回，否则会堆积成"垃圾"。</li>
</ul>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">void foo() {
    int a = 10;      // 栈分配，自动释放
    int* p = malloc(sizeof(int)); // 堆分配，需要手动free
    *p = 20;
    free(p);         // 忘记就会泄漏
}
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let a = 10;           // 栈分配，自动释放
    let p = Box::new(20); // 堆分配，离开作用域自动释放
} // p和a都被自动释放，无需手动管理
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Rust让你不用再担心"仓库忘记清理"的问题。</p>
</blockquote>
<hr />
<h3 id="245-指针引用与数据竞争"><a class="header" href="#245-指针引用与数据竞争">2.4.5 指针、引用与数据竞争</a></h3>
<ul>
<li><strong>C语言的指针</strong>：灵活但危险，容易出现野指针、悬垂指针和数据竞争。</li>
<li><strong>Rust的引用</strong>：更安全，编译器会帮你检查，防止悬垂引用和数据竞争。</li>
</ul>
<p><strong>C语言多线程数据竞争示例：</strong></p>
<pre><code class="language-c">int counter = 0;
void* thread_func(void*) {
    for (int i = 0; i &lt; 10000; ++i) {
        counter++; // 多线程下可能出现数据竞争
    }
}
</code></pre>
<p><strong>Rust多线程安全示例：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..2 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("结果: {}", *counter.lock().unwrap());
}</code></pre></pre>
<blockquote>
<p>Rust强制你用Arc和Mutex来保证多线程安全，编译器会阻止不安全的并发代码。</p>
</blockquote>
<h2 id="25-内存管理方式的演变深入讲解"><a class="header" href="#25-内存管理方式的演变深入讲解">2.5 内存管理方式的演变（深入讲解）</a></h2>
<p>在C语言中，内存管理完全依赖开发者手动操作。比如：</p>
<pre><code class="language-c">// C语言：手动分配和释放内存
int* p = (int*)malloc(sizeof(int));
*p = 42;
free(p); // 如果忘记free，就会内存泄漏
</code></pre>
<h3 id="什么是野指针"><a class="header" href="#什么是野指针">什么是"野指针"？</a></h3>
<p>野指针指的是指向已经被释放或未初始化内存的指针。比如：</p>
<pre><code class="language-c">int* p = (int*)malloc(sizeof(int));
free(p);
*p = 10; // 此时p已经是野指针，操作会导致未定义行为
</code></pre>
<p>这种错误在C/C++中很常见，可能导致程序崩溃甚至安全漏洞。</p>
<h3 id="rust如何避免野指针"><a class="header" href="#rust如何避免野指针">Rust如何避免野指针？</a></h3>
<p>Rust通过所有权和生命周期机制，保证变量离开作用域时自动释放内存，且禁止悬垂引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = Box::new(42);
    // x在这里有效
} // 这里x自动释放，之后无法再访问x
// println!("{}", x); // 编译报错：x已被释放
<span class="boring">}</span></code></pre></pre>
<p>Rust编译器会在编译期阻止所有悬垂指针和野指针的出现。</p>
<h3 id="什么是内存泄漏"><a class="header" href="#什么是内存泄漏">什么是"内存泄漏"？</a></h3>
<p>内存泄漏是指程序分配了内存但没有释放，导致内存资源被长期占用。例如：</p>
<pre><code class="language-c">void leak() {
    int* p = (int*)malloc(100);
    // 忘记free(p);
}
</code></pre>
<p>C/C++中这种问题很难彻底避免。</p>
<p>Rust的所有权机制让资源自动释放，极大降低了内存泄漏的风险。</p>
<hr />
<h2 id="26-栈与堆的基础知识结合c与rust对比"><a class="header" href="#26-栈与堆的基础知识结合c与rust对比">2.6 栈与堆的基础知识（结合C与Rust对比）</a></h2>
<ul>
<li><strong>栈</strong>：像快递员送快递，先进后出，速度快，但空间有限。</li>
<li><strong>堆</strong>：像仓库，随时存取，但需要自己记得取回，否则会堆积成"垃圾"。</li>
</ul>
<h3 id="c语言中的栈与堆"><a class="header" href="#c语言中的栈与堆">C语言中的栈与堆</a></h3>
<pre><code class="language-c">void foo() {
    int a = 10;      // 栈分配，foo结束自动释放
    int* p = malloc(sizeof(int)); // 堆分配，需要手动free
    *p = 20;
    // ...
    free(p);         // 忘记就会泄漏
}
</code></pre>
<h3 id="rust中的栈与堆"><a class="header" href="#rust中的栈与堆">Rust中的栈与堆</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let a = 10;           // 栈分配，自动释放
    let p = Box::new(20); // 堆分配，离开作用域自动释放
    // ...
} // 这里p和a都被自动释放，无需手动管理
<span class="boring">}</span></code></pre></pre>
<p>Rust的所有权和生命周期机制让你不用再担心"仓库忘记清理"的问题。</p>
<hr />
<h2 id="27-指针引用与数据竞争重点对比与举例"><a class="header" href="#27-指针引用与数据竞争重点对比与举例">2.7 指针、引用与数据竞争（重点对比与举例）</a></h2>
<h3 id="c语言的指针与常见问题"><a class="header" href="#c语言的指针与常见问题">C语言的指针与常见问题</a></h3>
<ul>
<li><strong>野指针</strong>：指向无效内存。</li>
<li><strong>悬垂指针</strong>：指向已释放的内存。</li>
<li><strong>数据竞争</strong>：多线程同时读写同一内存，导致结果不可预测。</li>
</ul>
<pre><code class="language-c">// C语言多线程数据竞争示例（伪代码）
int counter = 0;
void* thread_func(void*) {
    for (int i = 0; i &lt; 10000; ++i) {
        counter++; // 多线程下可能出现数据竞争
    }
}
</code></pre>
<p>如果两个线程同时修改counter，可能导致最终结果错误。</p>
<h3 id="rust如何防止数据竞争"><a class="header" href="#rust如何防止数据竞争">Rust如何防止数据竞争？</a></h3>
<p>Rust在编译期就会检查多线程共享变量的可变性和所有权，防止数据竞争：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..2 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("结果: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p>Rust强制你用Arc（原子引用计数）和Mutex（互斥锁）来保证多线程安全，编译器会阻止不安全的并发代码。</p>
<h3 id="rust的引用安全"><a class="header" href="#rust的引用安全">Rust的引用安全</a></h3>
<p>Rust区分可变引用（&amp;mut T）和不可变引用（&amp;T），同一时间只能有一个可变引用或多个不可变引用，杜绝了数据竞争和悬垂引用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
let y = &amp;mut x;
*y += 1;
// let z = &amp;x; // 编译报错：不能同时有可变和不可变引用
<span class="boring">}</span></code></pre></pre>
<p>这种严格的规则虽然一开始不太习惯，但极大提升了代码的安全性。</p>
<hr />
<h2 id="28-工程实践与团队协作"><a class="header" href="#28-工程实践与团队协作">2.8 工程实践与团队协作</a></h2>
<p>Rust自带包管理和构建工具（cargo），新建、编译、测试、依赖管理一站式完成。推荐团队统一使用rustfmt（代码格式化）、clippy（代码静态检查），保证代码风格一致、质量可控。</p>
<ul>
<li><strong>文档注释</strong>：使用<code>///</code>为函数和模块添加文档注释。</li>
<li><strong>自动生成文档</strong>：<code>cargo doc --open</code>可以生成并打开项目文档。</li>
<li><strong>单元测试</strong>：Rust内置测试框架，<code>cargo test</code>一键运行所有测试。</li>
</ul>
<p>这些工具和规范，有助于团队协作和代码维护。</p>
<hr />
<h2 id="29-常见问题解答"><a class="header" href="#29-常见问题解答">2.9 常见问题解答</a></h2>
<ul>
<li><strong>Rust为什么没有GC？</strong>
Rust通过所有权和生命周期机制，在编译期自动管理内存，无需运行时GC，既安全又高效。</li>
<li><strong>Rust和C++的RAII有什么不同？</strong>
Rust的所有权和借用机制更严格，能在编译期发现更多潜在问题，C++的RAII主要依赖开发者自律。</li>
<li><strong>Rust适合哪些项目？</strong>
适合对安全性、性能要求高的系统级开发，如操作系统、嵌入式、Web后端、高性能服务等。</li>
<li><strong>哪些场景下不建议用Rust？</strong>
对开发效率要求极高、生态依赖特定语言的快速原型开发，可能更适合用动态语言。</li>
</ul>
<h2 id="210-小结与思考题"><a class="header" href="#210-小结与思考题">2.10 小结与思考题</a></h2>
<p>本章我们回顾了编程语言的发展，了解了Rust的诞生背景、设计目标和核心优势，并完成了开发环境的安装和第一个程序的编写。Rust以其独特的安全性和高性能，正在成为越来越多企业的首选。</p>
<h3 id="思考题-1"><a class="header" href="#思考题-1">思考题</a></h3>
<ol>
<li>你认为C语言在现代开发中最大的优势和劣势分别是什么？</li>
<li>Rust的所有权机制能解决哪些C语言常见的bug？</li>
<li>试着用C语言写一个"Hello, world!"程序，并与Rust的版本进行对比，有哪些异同？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版权声明"><a class="header" href="#版权声明">版权声明</a></h1>
<p>《New for Rust》教程及其配套资料，版权归作者及项目团队所有。</p>
<p>本教程面向有一点C语言基础但对Rust不熟悉的开发者，旨在推广Rust语言的学习与工程实践，支持企业内部培训和个人自学。除非特别说明，教程内容采用以下授权方式：</p>
<ul>
<li><strong>个人学习与非商业用途</strong>：允许自由阅读、下载、引用和分享本教程内容，但请注明出处。</li>
<li><strong>企业内部培训</strong>：欢迎企业在内部培训、学习小组等场景中使用本教程内容，无需额外授权，但请勿对内容进行大规模修改后以自有名义发布。</li>
<li><strong>开源社区交流</strong>：欢迎在开源社区、技术论坛等非商业场合分享、讨论本教程内容，鼓励二次创作和经验交流，但请保留原作者信息。</li>
<li><strong>禁止商业出版与盈利性传播</strong>：未经作者或项目团队书面许可，禁止将本教程内容用于商业出版、付费课程、盈利性传播等用途。</li>
</ul>
<p>本教程部分内容参考了Rust官方文档、开源社区资料及相关技术书籍，均已注明出处。如有版权疑问或合作需求，请联系作者或项目团队。</p>
<p><strong>版权所有 © 2024 New for Rust 项目组 保留所有权利</strong></p>
<p>喜欢的话可以请我喝杯奶茶</p>
<p align = "center">
<img src="assets/qrcode.png" alt="支付宝" width="300" />
</p>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
