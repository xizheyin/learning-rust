<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>New for Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">New for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xizheyin/learning-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="本书介绍"><a class="header" href="#本书介绍">本书介绍</a></h1>
<h2 id="为什么要有这本书"><a class="header" href="#为什么要有这本书">为什么要有这本书？</a></h2>
<p>很多人觉得 Rust 难学，第一反应是"这门语言语法太怪了""所有权、生命周期太抽象了"，但实际上，<strong>大部分人学不会 Rust，并不是因为 Rust 本身有多难，而是因为缺乏计算机基础知识</strong>。</p>
<p>在实际教学和企业培训中，我们发现：</p>
<ul>
<li>很多同学虽然学过 C 语言，但对内存、进程、线程、文件系统、编译原理等底层知识并不扎实。</li>
<li>一旦遇到 Rust 的所有权、借用、并发安全等设计理念，就会觉得"无从下手"，其实是因为底层原理没打好基础。</li>
<li>很多 Rust 的"难点"，其实是现代系统编程的通用难点，只不过 Rust 让你必须正视它们。</li>
</ul>
<p><strong>本书的最大特色，就是在 Rust 学习过程中，穿插讲解计算机基础知识，也就是"内力"。</strong></p>
<p>你不仅能学到 Rust 的语法和工程实践，还能系统梳理计算机组成、内存管理、操作系统、并发原理等底层知识。
很多 Rust 的设计点，都会结合其他语言（更多是C/C++）和底层原理对比讲解，帮助你建立"迁移思维"。
这样学 Rust，不仅能写出高质量代码，更能打下坚实的计算机基础，为后续学习任何系统级开发打好底子。</p>
<h2 id="ai-时代为什么更要修炼内力"><a class="header" href="#ai-时代为什么更要修炼内力">AI 时代，为什么更要修炼"内力"？</a></h2>
<p>也许你会问：现在AI工具这么强大，写代码都能自动生成了，为什么还要花时间打基础、学底层？</p>
<p><strong>答案很简单：AI可以帮你写代码，但只有你自己理解底层原理，才能写出真正高质量、可控、安全的系统。</strong></p>
<p>AI能帮你生成函数、补全语法，但遇到复杂的系统设计、性能优化、并发安全、底层bug时，只有"内力"深厚的人才能看懂、调优、把控全局。
如果你只会"用AI抄代码"，遇到AI生成的代码有隐患、性能瓶颈、架构缺陷时，你很难发现和修正。
未来AI会成为开发者的好帮手，但<strong>只有基础扎实、理解原理的人，才能驾驭AI工具，而不是被AI限制思维和能力</strong>。</p>
<p><strong>所以，AI时代更要修炼内力。</strong>
你会发现，越是底层功夫扎实，越能用AI做更高效的开发、做更有创造力的系统设计。
这本书希望带你"内外兼修"，让你在AI时代依然有不可替代的核心竞争力。</p>
<p><strong>适合人群：</strong></p>
<ul>
<li>有 C 语言基础，但对底层原理不熟悉的开发者</li>
<li>希望补齐"内力"，真正理解现代编程语言设计的同学</li>
<li>想在企业、团队中推动高质量开发和工程实践的工程师</li>
</ul>
<blockquote>
<p>这本书不是单纯教你 Rust 语法，而是带你"内外兼修"，让你在学 Rust 的同时，补齐计算机基础，提升底层功力，成为真正的现代系统开发者。</p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="./ch0.html">为什么是这本书</a></li>
<li><a href="./ch1.html">Rust语言背景与发展</a></li>
<li><a href="./ch2.html">学习Rust的计算机基础</a></li>
<li><a href="./ch3.html">程序的编译与执行流程</a></li>
<li><a href="./ch4.html">Rust语言特性</a></li>
<li><a href="copyright.html">版权声明</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章rust语言背景与发展"><a class="header" href="#第一章rust语言背景与发展">第一章：Rust语言背景与发展</a></h1>
<h2 id="11-计算机语言发展简史"><a class="header" href="#11-计算机语言发展简史">1.1 计算机语言发展简史</a></h2>
<p>在正式学习Rust之前，我们先来回顾一下计算机编程语言的发展历程。C语言自1972年诞生以来，凭借其高效、灵活和接近底层的特性，成为了系统级开发的事实标准。此后，C++、Java、Python、Go等语言相继出现，各自针对不同的应用场景和开发需求进行了优化。</p>
<p>然而，随着软件系统的复杂度不断提升，传统语言在安全性、并发性和可维护性方面逐渐暴露出一些问题。例如，C/C++容易出现内存泄漏、野指针、数据竞争等难以排查的bug。为了解决这些问题，Rust应运而生。</p>
<h2 id="12-rust的诞生背景与设计目标"><a class="header" href="#12-rust的诞生背景与设计目标">1.2 Rust的诞生背景与设计目标</a></h2>
<p>Rust最初由Mozilla工程师Graydon Hoare于2010年发起，目标是打造一种既能像C/C++一样高效，又能最大程度保证安全性的系统级编程语言。Rust的核心设计理念包括：</p>
<ul>
<li>
<p><strong>内存安全</strong>：指的是程序不会出现"野指针"、"悬垂引用"或"内存泄漏"等问题。可以理解为你租了一间房子，钥匙只在你手里，搬走时房东会自动收回钥匙，别人无法再进来捣乱。Rust通过所有权（Ownership）和借用（Borrowing）机制，保证每一块内存都有明确的"主人"，用完就自动归还，防止"房子没人管"或"钥匙乱传"导致的混乱。</p>
<ul>
<li>许多传统语言（如C、C++）没有内存安全机制，开发者需要手动管理内存，容易出现野指针、内存泄漏等问题。Java、Python等虽然有垃圾回收（GC），但仍可能因引用遗留等原因出现内存泄漏。</li>
</ul>
</li>
<li>
<p><strong>并发安全</strong>：并发是指多个任务（比如多个线程）同时运行。并发安全意味着不会因为多个线程同时操作同一份数据而出错。就像几个人同时往同一个快递箱里放东西，如果没有规则，可能会把东西弄丢或打架。Rust在编译阶段就会检查你的代码，确保不会出现"数据竞争"，即不会有两个线程同时修改同一份数据，避免了多线程下常见的隐蔽bug。</p>
<ul>
<li>C、C++等语言的并发安全主要靠开发者自觉和手动加锁，编译器无法帮你发现数据竞争。Java、Python等虽然有线程机制，但也无法在编译期彻底防止并发bug。</li>
</ul>
</li>
<li>
<p><strong>高性能</strong>：Rust追求和C/C++一样的运行效率。所谓"零成本抽象"，就是你用高级语法写的代码，编译后和手写底层代码一样快，没有额外的性能损耗。比如你用for循环、迭代器等高级写法，编译器会自动优化成最快的机器码，既易写易读，又不牺牲速度。</p>
<ul>
<li>一些高级语言（如Python、JavaScript）虽然易用，但由于解释执行或虚拟机机制，运行效率远低于C、C++和Rust。C++虽然高效，但有些高级特性（如虚函数、多态）会带来一定的性能开销。</li>
</ul>
</li>
<li>
<p><strong>现代化工具链</strong>：Rust自带一整套开发工具，比如包管理（cargo）、自动化测试、文档生成、代码格式化等。就像买了一台新电脑，系统和常用软件都帮你装好了，不用再到处找驱动、装插件。这样可以大大提升开发效率，团队协作也更方便。</p>
<ul>
<li>许多老牌语言（如C、C++）缺乏统一的官方工具链，包管理、构建、测试等需要依赖第三方工具，配置繁琐。Python、Java等虽然有包管理工具，但集成度和一致性不如Rust的cargo。</li>
</ul>
</li>
</ul>
<h2 id="13-rust与cc的对比"><a class="header" href="#13-rust与cc的对比">1.3 Rust与C/C++的对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>C/C++</th><th>Rust</th></tr></thead><tbody>
<tr><td>内存管理</td><td>手动/RAII</td><td>所有权+借用+生命周期</td></tr>
<tr><td>并发安全</td><td>需开发者自行保证</td><td>编译器静态检查，防止数据竞争</td></tr>
<tr><td>错误处理</td><td>返回码/异常</td><td>Result/Option类型</td></tr>
<tr><td>包管理</td><td>无统一标准</td><td>cargo一站式解决</td></tr>
<tr><td>生态</td><td>成熟，历史悠久</td><td>新兴，发展迅速</td></tr>
</tbody></table>
</div>
<p>Rust并不是要取代C/C++，而是为系统级开发提供一种更安全、更现代的选择。</p>
<h2 id="14-rust的实际应用与生态"><a class="header" href="#14-rust的实际应用与生态">1.4 Rust的实际应用与生态</a></h2>
<p>Rust不仅在技术圈内备受推崇，近年来更是上升到国家战略层面。2024年，美国拜登政府发布政策，<strong>明确推动在关键基础设施和政府软件项目中采用Rust语言，理由是Rust能有效防止内存安全漏洞，提升国家网络安全水平</strong>。这一政策被多家主流媒体和安全专家解读为"软件安全领域的里程碑"。</p>
<p>Rust的影响力远不止于此：</p>
<ul>
<li><strong>工业界广泛应用</strong>：微软、亚马逊、谷歌、Meta（Facebook）、Cloudflare等科技巨头都在核心产品中引入Rust。例如，微软在Windows底层组件中逐步用Rust替换C/C++，以减少安全漏洞；亚马逊的云服务（AWS）也有大量Rust代码。</li>
<li><strong>开源社区活跃</strong>：Rust连续多年被Stack Overflow评为"最受欢迎的编程语言"，社区贡献者众多，生态繁荣。参考：<a href="https://survey.stackoverflow.co/2024/technology#admired-and-desired-language-desire-admire">https://survey.stackoverflow.co/2024/technology#admired-and-desired-language-desire-admire</a></li>
<li><strong>安全与高性能并重</strong>：Rust被广泛用于浏览器引擎（如Firefox的Servo）、区块链、嵌入式、物联网、Web后端等领域，尤其适合对安全性和性能要求极高的场景。</li>
<li><strong>政策推动与标准化</strong>：除了美国，欧盟、日本等也在推动关键基础设施采用更安全的系统级语言，Rust成为首选之一。</li>
<li><strong>中国科技巨头积极采用</strong>：阿里巴巴、字节跳动、腾讯、华为等国内大型互联网公司也在核心系统、云计算、数据库、区块链等领域积极引入Rust。例如，阿里巴巴在云原生基础设施和高性能服务中使用Rust提升安全性和并发性能；字节跳动在推荐系统、分布式存储等场景采用Rust重构关键模块；腾讯和华为也在操作系统、物联网等项目中推动Rust的落地。越来越多的中国初创公司和开源社区也在拥抱Rust，推动其在国内生态的繁荣发展。</li>
</ul>
<p>这些趋势表明，Rust不仅是技术创新的代表，更是全球软件安全和基础设施现代化的重要推动力。学习Rust，不仅能提升个人技术竞争力，也有助于把握未来行业发展的脉搏。</p>
<h2 id="15-安装rust开发环境"><a class="header" href="#15-安装rust开发环境">1.5 安装Rust开发环境</a></h2>
<p>下面我们来动手安装Rust开发环境，并编写第一个Rust程序。</p>
<h3 id="151-安装rust"><a class="header" href="#151-安装rust">1.5.1 安装Rust</a></h3>
<p>在Linux/macOS终端或Windows的WSL中，执行以下命令：</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>根据提示完成安装后，重启终端，输入：</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<p>如果能看到版本号，说明安装成功。</p>
<h3 id="152-配置vscode插件"><a class="header" href="#152-配置vscode插件">1.5.2 配置VSCode插件</a></h3>
<p>推荐安装"rust-analyzer"插件，获得更好的代码补全和语法提示体验。</p>
<h3 id="153-创建第一个rust项目"><a class="header" href="#153-创建第一个rust项目">1.5.3 创建第一个Rust项目</a></h3>
<p>使用cargo新建项目：</p>
<pre><code class="language-bash">cargo new hello_rust
cd hello_rust
cargo run
</code></pre>
<p>你会看到输出：</p>
<pre><code>Hello, world!
</code></pre>
<h4 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h4>
<p><code>src/main.rs</code> 文件内容如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>是不是很熟悉？和C语言的<code>printf</code>类似，但Rust的<code>println!</code>是一个宏，后续我们会详细讲解。</p>
<h2 id="16-小结与思考题"><a class="header" href="#16-小结与思考题">1.6 小结与思考题</a></h2>
<p>本章我们回顾了编程语言的发展，了解了Rust的诞生背景、设计目标和核心优势，并完成了开发环境的安装和第一个程序的编写。Rust以其独特的安全性和高性能，正在成为越来越多企业的首选。</p>
<h3 id="思考题"><a class="header" href="#思考题">思考题</a></h3>
<ol>
<li>你认为C语言在现代开发中最大的优势和劣势分别是什么？</li>
<li>Rust的所有权机制能解决哪些C语言常见的bug？</li>
<li>试着用C语言写一个"Hello, world!"程序，并与Rust的版本进行对比，有哪些异同？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章计算机基础与rust定位"><a class="header" href="#第二章计算机基础与rust定位">第二章：计算机基础与Rust定位</a></h1>
<p>对于一些小白来说，第一章我们操作的安装Rust的操作，其实是一知半解的。Rust是一个编程语言 or 软件 or 什么别的？ <code>cargo</code>又是什么东西。其实在学习编程的时候，很多人都是被这些底层的原理给吓跑了，因为在学校的时候，我们只是按照书本上的内容进行操作，进行配置环境，但是问到这是怎么运行的，就会说："我不道啊，都是老师教的。"这一章就是用来补齐一些计算机基础，从第一步开始就<strong>稳扎稳打、注重内力</strong>，这不仅对学习Rust有帮助，这是学习任何计算机相关的知识的基础。本章会有非常多的反复的类比，旨在形象地强化一些概念。</p>
<h2 id="21-计算机系统的基本组成"><a class="header" href="#21-计算机系统的基本组成">2.1 计算机系统的基本组成</a></h2>
<p>计算机系统主要由<em>硬件</em>和<em>软件</em>两大部分组成，二者密不可分：</p>
<ul>
<li><strong>硬件</strong>：计算机的"躯壳"，包括CPU（中央处理器）、内存（RAM）、硬盘（存储）、输入输出设备（如键盘、鼠标、显示器等）。</li>
<li><strong>软件</strong>：计算机的"灵魂"，包括操作系统（如Windows、Linux、macOS）和各种应用程序（如微信、浏览器、游戏等）。软件通过一系列指令控制硬件完成各种任务。</li>
</ul>
<p>也可以用厨房来比喻：</p>
<ul>
<li><strong>CPU</strong> 就像厨师，负责思考和做菜（处理数据和指令）。</li>
<li><strong>内存</strong> 就像操作台，厨师把正在做的菜和用到的食材都放在这里，方便随时拿取。</li>
<li><strong>硬盘</strong> 就像储藏室，存放大量还没用到的食材和工具，需要时再拿出来。</li>
<li><strong>输入设备</strong>（如键盘、鼠标）就像点菜的顾客或送菜的服务员，把需求和信息传递给厨师。</li>
<li><strong>输出设备</strong>（如显示器、打印机）就像上菜窗口，把做好的菜端给顾客。</li>
<li><strong>软件</strong> 就像菜谱和餐厅的规则，指导厨师和服务员如何协作。</li>
</ul>
<p>整个厨房高效运作，离不开每个环节的协作，这就像计算机硬件和软件的分工一样。</p>
<h3 id="思考与解释"><a class="header" href="#思考与解释">思考与解释：</a></h3>
<ul>
<li><strong>为什么内存比硬盘小很多，但速度快很多？</strong>
<ul>
<li>类比：
<ul>
<li>操作台（内存）空间有限，但厨师可以非常快地拿取和处理。</li>
<li>储藏室（硬盘）空间大，但每次取用都要走一趟，速度慢得多。</li>
</ul>
</li>
<li>内存技术快但贵，硬盘容量大但慢。</li>
</ul>
</li>
<li><strong>为什么不能把所有东西都放在内存？</strong>
<ul>
<li>操作台太大既贵又占地方，很多食材暂时用不到，放在储藏室更合适。</li>
</ul>
</li>
<li><strong>为什么程序运行时要"加载"到内存？</strong>
<ul>
<li>就像厨师做菜前要把食材从储藏室拿到操作台，程序运行前也要把数据和指令从硬盘搬到内存，CPU才能高效处理。</li>
</ul>
</li>
</ul>
<h2 id="22-软件是如何运行的"><a class="header" href="#22-软件是如何运行的">2.2 软件是如何运行的</a></h2>
<h3 id="221-编程语言和编译器"><a class="header" href="#221-编程语言和编译器">2.2.1 编程语言和编译器</a></h3>
<p>计算机只能识别0和1（二进制），所有数据和指令最终都要转成0/1（二进制文件）。十六进制常用于表示内存地址和数据，便于阅读和调试。
而人类能理解的语言是自然语言，例如英语。所以如何让计算机理解人类的指令是很关键的。</p>
<p>**而自然语言是有歧义的。**例如：这个人的头发长得奇怪。究竟是头发长度长的奇怪，还是头发的形状看起来奇怪？
那么，我们就需要一种人类能够理解的，能够翻译成0和1二进制代码的，无二义性的东西，作为人和计算机之间的桥梁。</p>
<p><strong>高级编程语言</strong>应运而生。而从人类编写的高级编程语言到机器能懂的二进制语言之间，需要一个翻译器 —— <strong>编译器（解释器）</strong></p>
<ul>
<li><strong>编译器</strong>：一种特殊的软件工具（"翻译器"），能把我们写的"高级语言"代码（如C、Rust）一次性翻译成计算机能直接执行的"机器码"，生成可执行文件，运行速度快。</li>
<li><strong>解释器</strong>：像"翻译员"，每次运行时逐行翻译代码，边翻译边执行，灵活但速度慢（如Python、JavaScript）。</li>
</ul>
<p>为什么会有两种不同的翻译器呢？其实，这和不同的需求和历史发展有关：</p>
<ul>
<li>
<p><strong>编译器</strong>（如C、Rust）：</p>
<ul>
<li>优点：一次性把全部代码翻译成机器码，生成可执行文件，运行速度快，适合对性能要求高的场景。</li>
<li>缺点：每次修改代码都要重新编译，开发调试周期稍长。</li>
<li>适用场景：操作系统、游戏、服务器等需要高性能的程序。</li>
<li>类比：像把一本英文小说全部翻译成中文再出版，读者可以直接看中文版，阅读体验流畅。</li>
</ul>
</li>
<li>
<p><strong>解释器</strong>（如Python、JavaScript）：</p>
<ul>
<li>优点：可以边写边运行，修改一行代码马上看到效果，开发效率高，适合快速试验和学习。</li>
<li>缺点：每次运行都要"翻译"一遍，速度慢一些。</li>
<li>适用场景：脚本、自动化、数据分析、网页前端等对性能要求不高、但开发灵活性要求高的场合。</li>
<li>类比：像有个翻译员在你身边，每读一句英文就翻译一句中文，虽然灵活但速度慢。</li>
</ul>
</li>
</ul>
<p><strong>历史背景</strong>：早期计算机资源有限，大家更关注运行效率，所以C、C++等编译型语言流行。随着计算机变快，开发效率变得更重要，解释型语言（如Python）开始流行，适合快速开发和原型设计。</p>
<p>我们在第一章安装的软件里面，其中一个很关键的就是编译器。Rust的编译器叫做rustc，而c、c++的编译器主流是gcc、g++、clang、clang++等。</p>
<h3 id="222-程序的运行流程"><a class="header" href="#222-程序的运行流程">2.2.2 程序的运行流程</a></h3>
<p>程序的运行大致分为以下几个步骤：</p>
<ol>
<li><strong>编写代码（高级语言）</strong>。开发者使用如Rust、C、Python等高级编程语言编写源代码。</li>
<li><strong>编译/解释生成二进制文件</strong>。源代码通过编译器（如rustc、gcc）或解释器（如python）被翻译成计算机能直接执行的机器码（二进制指令）。编译型语言会生成可执行文件，解释型语言则在运行时逐行翻译执行。</li>
<li><strong>存入硬盘</strong>。编译生成的可执行二进制文件或脚本文件被保存到硬盘等存储介质中。</li>
<li><strong>操作系统加载到内存</strong>。当用户运行程序时，操作系统会将可执行文件从硬盘加载到内存。只有在内存中的程序才能被CPU访问和执行。</li>
<li><strong>CPU执行指令</strong>。CPU从内存中读取指令，逐条执行，实现程序的功能。</li>
</ol>
<p>简而言之：代码经过编译/解释后生成二进制文件，存储在硬盘，运行时由操作系统加载到内存，最终由CPU执行。</p>
<h2 id="23-操作系统基础"><a class="header" href="#23-操作系统基础">2.3 操作系统基础</a></h2>
<p>操作系统（Operating System, OS）是管理和协调计算机硬件与软件资源的核心系统软件。</p>
<blockquote>
<p>例子：Windows、Linux、macOS、Android</p>
</blockquote>
<p>直观来看，操作系统就是给我们提供用户界面的一个东西，方便我们操作。
但实际上，并不是这样，图形用户界面（GUI）只是操作系统很小的一部分！</p>
<h3 id="操作系统到底是什么"><a class="header" href="#操作系统到底是什么">操作系统到底是什么？</a></h3>
<p>这里是一个主板，有非常复杂的硬件：
<img src="./assets/cpu.png" alt="主板" /></p>
<p>如果没有操作系统，每个我们编写的程序都必须自己负责：
如何让CPU执行自己的指令；
如何分配和管理内存；
如何读写硬盘、显示内容、响应键盘鼠标等外设；
如何和其他程序"和平共处"，避免互相干扰。
这会让每个程序都变得极其复杂，而且容易出错，甚至会导致系统崩溃或数据丢失。</p>
<p>操作系统的作用就是：</p>
<ul>
<li>统一管理和调度硬件资源，简化程序开发；</li>
<li>让多个程序可以安全、稳定地同时运行，互不干扰；</li>
<li>提供标准的接口和服务（如文件系统、网络、图形界面等），让开发者专注于自己的业务逻辑。</li>
</ul>
<p>有了操作系统，开发者只需要关心"做什么"，而不必关心"怎么和硬件打交道"，大大提升了开发效率和系统安全性。</p>
<p>在程序运行过程中，操作系统负责下面的工作：</p>
<ul>
<li>把程序从硬盘加载到内存；</li>
<li>分配CPU资源让程序执行；</li>
<li>管理程序运行时产生的数据和文件；</li>
<li>处理输入输出（如键盘、鼠标、网络等）。</li>
</ul>
<p>这样我们编写的程序只需要调用下面这样的接口就好了。</p>
<p>对于c语言：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE *fp = fopen("test.txt", "w"); // 打开文件，写入模式
    if (fp == NULL) {
        printf("无法打开文件\n");
        return 1;
    }
    fprintf(fp, "Hello, world!\n"); // 写入内容
    fclose(fp); // 关闭文件
    return 0;
}
</code></pre>
<p>对于Rust：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Write;

fn main() {
    let mut file = File::create("test.txt").expect("无法创建文件");
    file.write_all(b"Hello, world!\n").expect("写入失败");
}
</code></pre></pre>
<p>否则，我们就要手动用代码操纵磁盘，来读取，这是非常痛苦且低效的！！！
简而言之，操作系统是所有程序运行的"总管"，没有操作系统，绝大多数应用程序都无法独立运行。
操作系统为我们提供了很多接口，用于管理和控制硬件，下面我会以C和Rust的例子来阐释。</p>
<h3 id="进程与线程并发与并行"><a class="header" href="#进程与线程并发与并行">进程与线程、并发与并行</a></h3>
<p>在现代操作系统中，<strong>进程</strong>和<strong>线程</strong>是实现多任务的两种基本单位。</p>
<ul>
<li>
<p><strong>进程</strong>：可以理解为正在运行的一个"程序实例"。比如你同时开着微信和浏览器，这就是两个进程。每个进程有自己独立的内存空间，互不干扰。</p>
<ul>
<li>类比：进程就像一栋大楼里的不同公司，各自有自己的办公室和员工，互不打扰。</li>
</ul>
</li>
<li>
<p><strong>线程</strong>：是进程内部的"执行小分队"，一个进程可以有多个线程同时工作。比如浏览器可以一边加载网页一边播放音乐，这通常是不同线程在协作。</p>
<ul>
<li>类比：线程就像公司里的不同部门，大家在同一个办公室里协作完成不同任务。</li>
</ul>
</li>
</ul>
<h4 id="并发与并行"><a class="header" href="#并发与并行">并发与并行</a></h4>
<ul>
<li><strong>并发</strong>：指的是多个任务"轮流"执行，看起来像同时进行（比如单核CPU下的多任务切换）。
<ul>
<li>类比：一个厨师轮流炒几道菜，虽然只有一口锅，但切换得快，顾客感觉每道菜都在做。</li>
</ul>
</li>
<li><strong>并行</strong>：指的是多个任务"真正"同时进行（比如多核CPU下，每个核各干一件事）。
<ul>
<li>类比：几位厨师各自炒一道菜，真正同时出锅，效率更高。</li>
</ul>
</li>
</ul>
<h4 id="为什么要有进程和线程"><a class="header" href="#为什么要有进程和线程">为什么要有进程和线程？</a></h4>
<p>有了操作系统，我们只需要用简单的接口就能让程序"多线程"运行，无需自己管理底层的CPU调度和资源分配。</p>
<h4 id="代码示例-1"><a class="header" href="#代码示例-1">代码示例</a></h4>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
void* thread_func(void* arg) {
    // 线程要做的事情
}
int main() {
    pthread_t tid;
    pthread_create(&amp;tid, NULL, thread_func, NULL); // 创建线程
    pthread_join(tid, NULL); // 等待线程结束
    return 0;
}
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        // 线程要做的事情
    });
    handle.join().unwrap(); // 等待线程结束
}</code></pre></pre>
<blockquote>
<p>只需几行代码，就能让程序同时做多件事。底层的线程调度、资源分配都由操作系统负责，开发者不用操心。</p>
</blockquote>
<h3 id="变量内存与地址"><a class="header" href="#变量内存与地址">变量、内存与地址</a></h3>
<p>我们只需声明变量，系统自动分配内存。需要获取地址时，也有标准写法。</p>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">int a = 10; //底层是编程语言操作操作系统在内存里开辟一块新区域
int* p = &amp;a; // 获取变量a在内存里的地址
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10;
let p = &amp;a; // 获取变量a的引用
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>不用关心内存的具体分配细节，操作系统和语言帮我们管理好。</p>
</blockquote>
<h3 id="文件与文件系统"><a class="header" href="#文件与文件系统">文件与文件系统</a></h3>
<p>如前所述，读写文件只需调用标准接口。</p>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">fopen("test.txt", "w"); // 打开文件
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>File::create("test.txt"); // 创建文件
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>不用自己操作磁盘硬件，操作系统帮我们完成所有底层工作。</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第三章程序的编译与执行流程"><a class="header" href="#第三章程序的编译与执行流程">第三章：程序的编译与执行流程</a></h1>
<p>不要看helloworld程序很简单，但是即使要运行如此简单的程序，也需要极其复杂的软件和硬件配合才行。</p>
<p>我们在写下hello world代码之后，点击某个按钮运行，在底层是如何运作的呢？这一章我们来了解一下，从<em>我们写下代码后点击运行</em>，到<em>程序给出一个结果</em>，计算机到底经过了什么样的过程。我们在了解了底层原理之后，就能够更容易理解编译器给我们的报错，以及我们运行时遇到的Bug。</p>
<h2 id="31-编译从代码到程序"><a class="header" href="#31-编译从代码到程序">3.1 编译：从代码到程序</a></h2>
<p>让我们通过具体的例子来了解编译流程，并解释每一步的原理。</p>
<h3 id="311-c语言编译流程详解"><a class="header" href="#311-c语言编译流程详解">3.1.1 C语言编译流程详解</a></h3>
<h4 id="编写源代码"><a class="header" href="#编写源代码">编写源代码</a></h4>
<p>这就是我们第一次学习计算机写的第一个helloworld程序：</p>
<pre><code class="language-c">// hello.c
#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}
</code></pre>
<p><code>include</code>指令是为了包含一些必要的库代码，例如上节课讲的打印的代码。我们再点击运行按钮的时候，计算机系统将运行编译指令，使用gcc或者clang来编译这个代码。</p>
<h4 id="预处理preprocessing"><a class="header" href="#预处理preprocessing">预处理（Preprocessing）</a></h4>
<p>编译器第一步就是进行预处理，计算机运行如下的指令：</p>
<pre><code class="language-bash">gcc -E hello.c -o hello.i
</code></pre>
<p>预处理后的文件 <code>hello.i</code> 内容：</p>
<pre><code class="language-c"># 1 "hello.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&lt;command-line&gt;" 2
# 1 "hello.c"
# 1 "/usr/include/stdio.h" 1 3 4
// ... 大量头文件内容 ...
extern int printf (const char *__restrict __format, ...);
// ... 更多内容 ...

int main() {
    printf("Hello, World!\n");
    return 0;
}
</code></pre>
<p>预处理阶段的主要工作是展开头文件。当我们写 <code>#include &lt;stdio.h&gt;</code> 时，编译器会把整个stdio.h文件的内容复制到我们的代码中。这个文件包含了printf函数的声明，以及其他很多标准库函数的定义。预处理还会处理宏定义，把 <code>#define</code> 定义的符号替换成实际的值，进行条件编译，根据 <code>#ifdef</code> 等条件决定哪些代码要编译，最后删除所有注释，因为计算机不需要看注释。</p>
<h4 id="编译compilation"><a class="header" href="#编译compilation">编译（Compilation）</a></h4>
<pre><code class="language-bash">gcc -S hello.i -o hello.s
</code></pre>
<p>编译阶段会把预处理后的代码转换成汇编代码。汇编代码非常接近机器代码，同时人也能看得懂，它可以直接操作硬件。生成的汇编文件包含了CPU能够理解的指令，比如把数据移动到寄存器、调用函数、返回结果等。</p>
<p>生成的汇编文件 <code>hello.s</code>：</p>
<pre><code class="language-assembly">    .file   "hello.c"
    .text
    .section    .rodata
.LC0:
    .string "Hello, World!"
    .text
    .globl  main
    .type   main, @function
main:
    pushq   %rbp
    movq    %rsp, %rbp
    leaq    .LC0(%rip), %rdi
    call    printf@PLT
    movl    $0, %eax
    popq    %rbp
    ret
    .size   main, .-main
</code></pre>
<p>编译阶段会进行语法检查和类型检查，确保我们的代码符合C语言的语法规则，变量类型使用正确。同时编译器会优化代码，删除无用的代码，提高程序的执行效率。</p>
<h4 id="汇编assembly"><a class="header" href="#汇编assembly">汇编（Assembly）</a></h4>
<pre><code class="language-bash">gcc -c hello.s -o hello.o
</code></pre>
<p>汇编阶段把汇编代码转换成目标文件。目标文件是二进制文件，由0和1构成，人类无法直接阅读。这个文件包含了机器码，也就是CPU能够直接执行的指令。</p>
<p>汇编器的主要工作是转换指令格式。它把汇编语言中的指令转换成对应的机器码，比如把 <code>mov</code> 指令转换成特定的二进制序列。同时汇编器会生成符号表，记录函数名、变量名等符号信息，这些信息在后面的链接阶段会用到。</p>
<h4 id="链接linking"><a class="header" href="#链接linking">链接（Linking）</a></h4>
<pre><code class="language-bash">gcc hello.o -o hello
</code></pre>
<p>链接阶段把目标文件转换成可执行文件。链接器会合并多个目标文件，解析符号引用，找到printf等函数的实际地址，把标准库、第三方库的代码合并进来，最终生成操作系统能识别的可执行文件格式。</p>
<p>链接器的一个重要工作是解析符号。当我们的代码调用printf函数时，编译器并不知道printf函数的具体实现在哪里。链接器会在标准库中找到printf函数的实现，并建立正确的调用关系。这样程序运行时就能正确调用到printf函数了。</p>
<h4 id="一步完成编译"><a class="header" href="#一步完成编译">一步完成编译</a></h4>
<pre><code class="language-bash">gcc hello.c -o hello
./hello
</code></pre>
<p>实际上我们通常不需要手动执行每一步，编译器可以一步完成所有工作。当我们运行 <code>gcc hello.c -o hello</code> 时，编译器内部会自动执行预处理、编译、汇编、链接的所有步骤，最终生成可执行文件。</p>
<h3 id="312-rust编译流程详解"><a class="header" href="#312-rust编译流程详解">3.1.2 Rust编译流程详解</a></h3>
<h4 id="编写源代码-1"><a class="header" href="#编写源代码-1">编写源代码</a></h4>
<p>Rust的hello world程序看起来更简洁：</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
fn main() {
    println!("Hello, World!");
}</code></pre></pre>
<p>Rust代码不需要显式包含头文件，因为Rust的模块系统会自动处理依赖关系。println!是一个宏，比C语言的printf更安全，它会在编译时检查参数类型，防止格式化字符串错误。</p>
<h4 id="编译"><a class="header" href="#编译">编译</a></h4>
<pre><code class="language-bash">rustc main.rs
</code></pre>
<p>Rust编译器只需要一步就能完成编译。虽然命令简单，但Rust的编译过程比C更复杂。编译器不仅要检查语法和类型，还要检查所有权和借用规则、生命周期、并发安全等Rust特有的安全特性。</p>
<p>Rust编译器会进行更严格的类型检查。它会确保所有变量都有明确的类型，检查引用是否有效，验证所有权转移是否正确。这些检查在编译时就能发现很多潜在的内存安全问题。</p>
<h4 id="运行"><a class="header" href="#运行">运行</a></h4>
<pre><code class="language-bash">./main
</code></pre>
<p>生成的可执行文件可以直接运行，输出结果和C语言程序一样。</p>
<h3 id="313-编译流程对比"><a class="header" href="#313-编译流程对比">3.1.3 编译流程对比</a></h3>
<div class="table-wrapper"><table><thead><tr><th>阶段</th><th>C语言命令</th><th>Rust命令</th><th>输出文件</th><th>主要区别</th></tr></thead><tbody>
<tr><td>预处理</td><td><code>gcc -E hello.c -o hello.i</code></td><td>自动处理</td><td><code>.i</code> 文件</td><td>Rust的宏系统更强大，预处理更智能</td></tr>
<tr><td>编译</td><td><code>gcc -S hello.i -o hello.s</code></td><td>自动处理</td><td><code>.s</code> 文件</td><td>Rust有更多安全检查，编译更复杂</td></tr>
<tr><td>汇编</td><td><code>gcc -c hello.s -o hello.o</code></td><td>自动处理</td><td><code>.o</code> 文件</td><td>原理相同，但Rust生成更多元数据</td></tr>
<tr><td>链接</td><td><code>gcc hello.o -o hello</code></td><td>自动处理</td><td>可执行文件</td><td>Rust的链接器更智能，依赖管理更好</td></tr>
<tr><td>一步完成</td><td><code>gcc hello.c -o hello</code></td><td><code>rustc main.rs</code></td><td>可执行文件</td><td>Rust自动化程度更高</td></tr>
</tbody></table>
</div>
<p>C语言需要手动管理编译步骤和文件依赖，开发者需要了解每个阶段的作用。Rust编译器自动处理所有细节，开发者只需要关注代码逻辑，编译器会确保代码的安全性。</p>
<h3 id="314-编译过程中的文件类型"><a class="header" href="#314-编译过程中的文件类型">3.1.4 编译过程中的文件类型</a></h3>
<p>编译过程中会生成不同类型的文件，每种文件都有特定的用途。</p>
<p>源代码文件是我们编写的程序，通常以.c或.rs为扩展名。这些文件人类可以阅读和编辑，包含了程序的逻辑和算法。</p>
<p>预处理文件是展开宏和头文件后的代码，通常以.i为扩展名。这个文件包含了所有头文件的内容，可以用来调试预处理阶段的问题。</p>
<p>汇编文件是转换成汇编语言的代码，通常以.s为扩展名。汇编代码接近机器语言，但仍然可以阅读，可以用来学习汇编语言或进行底层优化。</p>
<p>目标文件是编译后的机器码，但还没有链接，通常以.o为扩展名。目标文件包含了机器指令，但函数调用还没有解析，不能直接运行。</p>
<p>可执行文件是最终的程序，可以直接运行。在Unix/Linux系统中，可执行文件通常没有扩展名，这是操作系统的传统。</p>
<h3 id="315-实际编译示例"><a class="header" href="#315-实际编译示例">3.1.5 实际编译示例</a></h3>
<p>让我们看一个更复杂的例子，理解为什么需要多文件编译。</p>
<h4 id="c语言多文件编译"><a class="header" href="#c语言多文件编译">C语言多文件编译</a></h4>
<p>在实际项目中，我们通常会把代码分成多个文件。比如一个简单的数学库：</p>
<pre><code class="language-c">// math.h - 头文件，声明函数
int add(int a, int b);
int multiply(int a, int b);

// math.c - 实现文件
#include "math.h"

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

// main.c - 主文件
#include &lt;stdio.h&gt;
#include "math.h"

int main() {
    int result1 = add(5, 3);
    int result2 = multiply(4, 6);
    printf("5 + 3 = %d\n", result1);
    printf("4 * 6 = %d\n", result2);
    return 0;
}
</code></pre>
<p>编译这样的多文件项目需要分步进行：</p>
<pre><code class="language-bash">gcc -c math.c -o math.o    # 编译math.c
gcc -c main.c -o main.o    # 编译main.c
gcc math.o main.o -o program  # 链接所有目标文件
</code></pre>
<p>分步编译的好处是可以进行增量编译。当我们只修改了main.c文件时，只需要重新编译main.c，然后重新链接，而不需要重新编译math.c。这样可以节省编译时间，特别是在大型项目中。</p>
<h4 id="rust多文件编译"><a class="header" href="#rust多文件编译">Rust多文件编译</a></h4>
<p>Rust的多文件编译更简单：</p>
<pre><pre class="playground"><code class="language-rust">// math.rs - 模块文件
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

pub fn multiply(a: i32, b: i32) -&gt; i32 {
    a * b
}

// main.rs - 主文件
mod math;  // 声明使用math模块

fn main() {
    let result1 = math::add(5, 3);
    let result2 = math::multiply(4, 6);
    println!("5 + 3 = {}", result1);
    println!("4 * 6 = {}", result2);
}</code></pre></pre>
<p>编译命令只需要一行：</p>
<pre><code class="language-bash">rustc main.rs  # 自动处理所有依赖
</code></pre>
<p>Rust编译器会自动分析文件依赖关系，找到所有需要的模块文件，然后并行编译，最后链接成可执行文件。这种自动化的依赖管理大大简化了项目的构建过程。</p>
<h2 id="32-程序运行时的底层原理"><a class="header" href="#32-程序运行时的底层原理">3.2 程序运行时的底层原理</a></h2>
<h3 id="321-程序是如何被加载的"><a class="header" href="#321-程序是如何被加载的">3.2.1 程序是如何被加载的？</a></h3>
<p>当我们运行 <code>./hello</code> 时，操作系统会执行一系列复杂的步骤来加载和启动程序。</p>
<p>首先，操作系统会解析可执行文件的头部信息。可执行文件包含了很多元数据，比如程序需要多少内存、需要哪些库文件、程序的入口点在哪里等。操作系统读取这些信息，为程序运行做准备。</p>
<p>然后，操作系统会为程序分配虚拟内存空间。现代操作系统使用虚拟内存技术，每个程序都以为自己独占了整个内存空间。操作系统负责把虚拟地址映射到物理地址，防止程序之间相互干扰。分配的内存空间包括代码段、数据段、栈、堆等不同的区域。</p>
<p>接下来，操作系统会把可执行文件的代码复制到内存中。代码段包含了程序的指令，数据段包含了全局变量和静态变量。操作系统会初始化这些变量，设置正确的初始值。</p>
<p>操作系统还会设置程序的栈和堆。栈用于存储局部变量和函数调用信息，它的分配和释放是自动的。堆用于动态分配内存，程序可以在运行时申请和释放堆内存。</p>
<p>最后，操作系统会跳转到程序的main函数开始执行。程序计数器被设置为main函数的地址，CPU开始执行程序的第一条指令。</p>
<h3 id="322-为什么需要这些步骤"><a class="header" href="#322-为什么需要这些步骤">3.2.2 为什么需要这些步骤？</a></h3>
<p>虚拟内存是现代操作系统的重要特性。它让每个程序都以为自己独占了整个内存空间，但实际上多个程序可以同时运行在有限的物理内存中。操作系统通过内存管理单元（MMU）把虚拟地址转换成物理地址，实现了内存隔离和保护。</p>
<p>栈和堆有不同的用途。栈是后进先出的数据结构，适合存储局部变量和函数调用信息。当函数被调用时，参数和返回地址被压入栈中；当函数返回时，这些信息被弹出栈。堆是动态分配的内存区域，程序可以在运行时申请任意大小的内存，但需要手动管理内存的分配和释放。</p>
<p>程序运行时还需要加载库文件。很多程序都使用了标准库函数，比如printf、malloc等。这些函数的代码不在我们的程序中，而是在系统库文件中。操作系统会在程序启动时把这些库文件加载到内存中，建立正确的函数调用关系。</p>
<h3 id="323-程序执行的过程"><a class="header" href="#323-程序执行的过程">3.2.3 程序执行的过程</a></h3>
<p>CPU执行程序的过程遵循冯·诺依曼体系结构的设计。程序和数据都存储在内存中，CPU按顺序执行指令。</p>
<p>CPU的执行过程包括五个步骤：取指令、解码、执行、写回、重复。首先，CPU从内存中读取下一条指令。指令通常包含操作码和操作数，操作码告诉CPU要执行什么操作，操作数告诉CPU操作的对象。</p>
<p>然后，CPU解码指令，理解这条指令要做什么。比如，如果指令是加法指令，CPU就知道要把两个数相加。接下来，CPU执行指令，进行实际的运算操作。运算的结果可能是一个数值，也可能是一个内存地址。</p>
<p>最后，CPU把结果写回到内存或寄存器中。寄存器是CPU内部的高速存储器，用于临时存储数据和地址。完成一条指令后，CPU继续执行下一条指令，这个过程不断重复，直到程序结束。</p>
<p>这种设计让CPU能够执行任何存储在内存中的程序，只要程序符合CPU的指令集架构。现代CPU还采用了流水线技术，可以同时处理多条指令的不同阶段，提高执行效率。</p>
<h2 id="33-理解编译错误和运行时错误"><a class="header" href="#33-理解编译错误和运行时错误">3.3 理解编译错误和运行时错误</a></h2>
<h3 id="331-编译错误的原理"><a class="header" href="#331-编译错误的原理">3.3.1 编译错误的原理</a></h3>
<p>编译错误发生在编译阶段，编译器会检查代码的语法和语义，发现问题时就会报错。</p>
<p>语法错误是最常见的编译错误。比如缺少分号、括号不匹配、关键字拼写错误等。编译器在语法分析阶段会检查代码是否符合编程语言的语法规则。如果发现语法错误，编译器会停止编译并显示错误信息。</p>
<pre><code class="language-c">int main() {
    printf("Hello, World!\n"  // 缺少分号
    return 0;
}
</code></pre>
<p>类型错误是另一种常见的编译错误。编译器会检查变量的类型使用是否正确，比如把字符串赋值给整数变量，或者调用函数时参数类型不匹配。</p>
<pre><code class="language-c">int main() {
    int a = "hello";  // 类型不匹配
    return 0;
}
</code></pre>
<p>编译器还会检查其他问题，比如未定义的变量、未声明的函数、重复定义等。这些检查帮助我们在程序运行前发现潜在的问题。</p>
<h3 id="332-运行时错误的原理"><a class="header" href="#332-运行时错误的原理">3.3.2 运行时错误的原理</a></h3>
<p>运行时错误发生在程序执行过程中，通常更难发现和调试。</p>
<p>段错误（Segmentation Fault）是一种常见的运行时错误。当程序试图访问无效的内存地址时，操作系统会终止程序并报告段错误。常见的原因包括访问空指针、访问已释放的内存、数组越界等。</p>
<pre><code class="language-c">int main() {
    int* ptr = NULL;
    *ptr = 42;  // 访问空指针，导致段错误
    return 0;
}
</code></pre>
<p>栈溢出是另一种运行时错误。当函数调用层次过深，或者局部变量占用过多栈空间时，就会发生栈溢出。无限递归是导致栈溢出的常见原因。</p>
<pre><code class="language-c">void infinite_recursion() {
    infinite_recursion();  // 无限递归，导致栈溢出
}
</code></pre>
<p>内存泄漏也是一种运行时问题。当程序分配了内存但没有释放时，就会造成内存泄漏。虽然程序可能正常运行，但会逐渐消耗系统内存，最终可能导致系统性能下降。</p>
<p>编译错误通常比运行时错误更容易发现和修复，因为编译器会明确指出错误的位置和原因。运行时错误可能只在特定条件下出现，需要更多的调试技巧来定位问题。</p>
<h2 id="34-思考题"><a class="header" href="#34-思考题">3.4 思考题</a></h2>
<ol>
<li>为什么C语言需要手动链接库文件，而Rust可以自动处理？</li>
<li>预处理阶段为什么要展开头文件？直接包含不行吗？</li>
<li>为什么需要汇编这一步？不能直接从高级语言生成机器码吗？</li>
<li>虚拟内存的作用是什么？为什么每个程序都需要？</li>
<li>编译错误和运行时错误的区别是什么？哪种更严重？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第四章rust语言特点总览"><a class="header" href="#第四章rust语言特点总览">第四章：Rust语言特点总览</a></h1>
<p>在前面的章节中，我们已经了解了Rust的背景和计算机基础知识。现在让我们深入探讨Rust的核心语言特点，通过与C语言的对比来理解Rust的设计理念和优势。</p>
<h2 id="40-核心概念解释"><a class="header" href="#40-核心概念解释">4.0 核心概念解释</a></h2>
<p>在开始对比之前，我们先来理解一些重要的编程概念。这些概念可能听起来很抽象，但实际上它们每天都在影响我们的编程工作。</p>
<h3 id="401-什么是类型系统"><a class="header" href="#401-什么是类型系统">4.0.1 什么是类型系统？</a></h3>
<p>我们通过代码操纵某种某些值，这个值需要有类型。类型告诉计算机这个数据是什么，也决定了能对这个数据做什么操作。
举一个生活中的例子，我们不能对两个类型为老虎进行相加减，但是我们可以对两个老虎的身高进行加减。而前者的类型是"老虎"，而后者的类型是"整数"</p>
<p>一些常见的类型：数字42的类型是整数，字符串"hello"的类型是文本，小数3.14的类型是浮点数。</p>
<p><strong>为什么需要类型系统？</strong>
类型系统帮助我们避免错误。比如我们不能把一个人的年龄和名字相加，同样在编程中，我们也应该避免把整数和字符串相加。类型系统会在编译时检查这些错误，防止程序运行时出现问题。</p>
<p><strong>静态类型 vs 动态类型：</strong>
静态类型语言（如C、Rust）在<strong>编译时</strong>就确定所有数据的类型，如果类型不匹配就会报错。动态类型语言（如Python、JavaScript）在运行时才确定类型，更灵活但可能出现<strong>运行时错误</strong>。</p>
<h3 id="402-什么是内存管理"><a class="header" href="#402-什么是内存管理">4.0.2 什么是内存管理？</a></h3>
<p>内存管理就像是管理一个巨大的仓库。
我们前面提到过，程序在运行的时候，数据是存储在硬件（内存）中的。
计算机的内存就像是一个大仓库，里面有很多小格子，每个格子可以存储一个数据。当我们写程序时，需要在这个仓库中分配空间来存储我们的数据。</p>
<p><strong>内存分配的过程：</strong>
当我们声明一个变量时，比如 <code>int a = 10;</code>，程序会向操作系统（回顾，操作系统的作用）申请一个内存格子来存储这个数字10。这个格子有固定的地址，程序通过这个地址来访问和修改数据。</p>
<p><strong>内存管理的问题：</strong>
内存是有限的资源，如果我们申请了内存但不释放，就会造成<em>内存泄漏</em>。就像在仓库中占用了格子但不用，其他程序就没法使用这些空间了。相反，如果我们释放了内存但还在使用，就会访问到无效的数据，导致程序崩溃，这叫<em>悬挂/垂指针（dangling pointer）</em>。</p>
<p><strong>手动管理 vs 自动管理：</strong>
C语言采用手动内存管理，程序员需要自己申请和释放内存。这给了程序员最大的控制权，但也容易出错。Rust采用自动内存管理，通过所有权机制在编译时确保内存的正确使用，既保证了性能又避免了常见的内存错误。</p>
<h3 id="403-什么是所有权"><a class="header" href="#403-什么是所有权">4.0.3 什么是所有权？</a></h3>
<p>想象一下，你是一个图书管理员（操作系统），可以给每一个人发书，但是每个人在使用完之后需要归还，因为图书馆的书是有限的（内存资源有限）。
这个图书馆有一个铁律：<strong>每本书只能有一个<em>所有者</em>，而且<em>所有者</em>必须负责归还这本书</strong>。</p>
<p><strong>所有权的核心思想：</strong>
在Rust的世界里，每个数据就像图书馆里的一本书。每本书被拿走后都有一个"所有者"，这个所有者有这本书的完全控制权。
"所有者"可以阅读这本书，可以把它借给别人，也可以把它扔掉。但是，当主人离开图书馆（<em>作用域</em>）时，如果这本书还在他手里，图书馆会自动把这本书收回来。</p>
<p>让我们跟着小明和小红的故事来理解所有权：</p>
<pre><code>小明走进图书馆，借了一本《Rust编程指南》。
现在小明是这本书的所有者，他可以：
- 阅读这本书
- 把书借给小红
- 把书的所有者身份交给小红（转移所有权）
- 把书还给图书馆（释放内存）

如果小明只是借给小红看一下，那么小明始终需要对这本书负责：
- 小明依然是这本书的所有者
- 小红看完需要还给小明
- 当小明离开图书馆时，图书馆会自动把书收回来。

如果小明把所有者身份给了小红，那么小明不必再对这本书负责了：
- 小明不再是这本书的主人
- 小红成为新的主人
- 小明不能再使用这本书
- 当小红离开图书馆时，如果书还在她手里，图书馆会自动把书收回来。

</code></pre>
<p><strong>所有权的三条铁律：</strong></p>
<ol>
<li><strong>每本书只能有一个主人</strong> - 每个值只能有一个所有者</li>
<li><strong>主人可以转移所有权</strong> - 所有者可以把值转移给其他人</li>
<li><strong>主人离开时书必须归还</strong> - 当所有者离开作用域时，值对应的内存会被自动释放</li>
</ol>
<p><strong>为什么需要所有权？</strong></p>
<p>在传统的编程语言中，就像图书馆允许一本书同时被多个人借阅一样，多个变量可以指向同一块内存。这听起来很方便，但实际上会造成混乱：</p>
<ul>
<li><strong>谁负责归还？</strong> 如果小明和小红都借了同一本书，谁应该归还？小明说我不是借给你了么，你还。小红说，那最开始不是你借的吗，你还！</li>
<li><strong>什么时候归还？</strong> 如果没人记得归还，书就会永远留在外面（内存泄漏）</li>
<li><strong>重复归还怎么办？</strong> 如果小明说他要还，小红说她也要还，图书馆会混乱（重复释放）</li>
</ul>
<p>Rust的所有权机制就像是一个严格的图书馆管理员，确保每本书只有一个借阅者，避免了所有这些混乱。<strong>所有权机制明确规定了到底是谁来对这块内存负责！！！！！！</strong></p>
<p><strong>生活中的其他例子：</strong></p>
<ul>
<li><strong>汽车钥匙</strong>：你有一把车钥匙，你可以开车，可以把钥匙给别人，但同一时间只能有一个人有钥匙</li>
<li><strong>银行账户</strong>：你的银行账户只能有一个主人，你可以转账给别人，但转账后你就失去了对这笔钱的控制</li>
<li><strong>房子</strong>：你拥有一套房子，你可以住，可以卖，可以租，但同一时间只能有一个房主</li>
</ul>
<hr />
<p><strong>技术概念精讲：</strong></p>
<p>所有权是Rust内存管理的核心机制，它通过编译时的静态分析来确保内存安全，无需运行时垃圾回收。</p>
<p><strong>所有权的技术定义：</strong></p>
<ul>
<li><strong>所有者（Owner）</strong>：拥有数据值的变量，负责管理该值的生命周期</li>
<li><strong>作用域（Scope）</strong>：变量有效的代码区域，从声明开始到作用域结束</li>
<li><strong>移动（Move）</strong>：所有权从一个变量转移到另一个变量，原变量变为无效</li>
<li><strong>释放（Drop）</strong>：当所有者离开作用域时，自动调用析构函数释放资源</li>
</ul>
<p><strong>所有权的技术规则：</strong></p>
<ol>
<li><strong>唯一性</strong>：每个值在任何时刻只能有一个所有者</li>
<li><strong>转移语义</strong>：赋值、函数参数传递、函数返回值都会转移所有权</li>
<li><strong>自动释放</strong>：当所有者离开作用域时，值会被自动释放</li>
</ol>
<p><strong>编译时检查：</strong>
Rust编译器在编译时分析每个变量的生命周期，确保：</p>
<ul>
<li>没有悬垂引用（dangling references）</li>
<li>没有数据竞争（data races）</li>
<li>没有内存泄漏（memory leaks）</li>
<li>没有重复释放（double free）</li>
</ul>
<p><strong>所有权与内存安全：</strong>
通过所有权机制，Rust在编译时就能发现潜在的内存安全问题，避免了C/C++中常见的运行时错误。这种设计既保证了内存安全，又保持了零成本抽象的性能优势。</p>
<h3 id="404-什么是错误处理"><a class="header" href="#404-什么是错误处理">4.0.4 什么是错误处理？</a></h3>
<p>错误处理就像是处理生活中的意外情况。当我们写程序时，很多事情可能出错：文件不存在、网络连接失败、用户输入无效等。程序需要优雅地处理这些错误，而不是<strong>直接崩溃</strong>：Segmentation fault (core dumped)。</p>
<p><strong>错误处理的挑战：</strong>
在C语言中，错误处理通常通过返回特殊值（如-1、NULL）来表示。这种方法简单，但容易忘记检查错误，也容易混淆正常值和错误值。</p>
<p><strong>Rust的错误处理：</strong>
Rust通过Result类型来处理错误。Result就像一个盒子，里面要么是成功的结果，要么是错误信息。程序<strong>必须明确处理这两种情况</strong>，不能忽略错误。这确保了程序的健壮性。</p>
<h3 id="405-什么是并发安全"><a class="header" href="#405-什么是并发安全">4.0.5 什么是并发安全？</a></h3>
<p>并发安全就像是多人同时使用同一个资源时的协调问题。想象一下，如果多个人同时往同一个银行账户存钱，我们需要确保每个人的操作都是安全的，不会相互干扰。</p>
<p><strong>并发的问题：</strong>
当多个线程同时访问同一个数据时，可能出现数据竞争。比如两个线程同时读取一个计数器，然后各自加1，最后写回。如果操作不当，可能只加了一次而不是两次。</p>
<p><strong>Rust的并发安全：</strong>
Rust通过类型系统在编译时检查并发安全问题。如果一个数据可能被多个线程同时访问，Rust会要求使用特殊的类型（如Mutex、Arc）来确保安全访问。这避免了运行时才发现并发错误。</p>
<p>现在我们对这些核心概念有了基本理解，接下来看看C语言和Rust在这些方面有什么不同。</p>
<h2 id="41-类型系统对比"><a class="header" href="#41-类型系统对比">4.1 类型系统对比</a></h2>
<h3 id="411-静态类型与类型推断"><a class="header" href="#411-静态类型与类型推断">4.1.1 静态类型与类型推断</a></h3>
<p>C语言和Rust都是静态类型语言，但Rust的类型推断让代码更简洁。</p>
<p><strong>C语言：</strong></p>
<pre><code class="language-c">int a = 10;           // 必须显式声明类型
int b = 20;
int result = a + b;   // 类型必须明确
</code></pre>
<p><strong>Rust：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10;           // 类型推断为 i32
let b = 20;           // 类型推断为 i32
let result = a + b;   // 自动推断为 i32
<span class="boring">}</span></code></pre></pre>
<p><strong>显式类型声明（Rust）：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: i32 = 10;      // 显式指定类型
let b: f64 = 3.14;    // 浮点数类型
<span class="boring">}</span></code></pre></pre>
<p>Rust的类型推断让代码更简洁，同时保持了静态类型的安全性。编译器能够根据上下文自动推断出变量的类型，减少了代码的冗余，但当我们需要明确指定类型时，仍然可以显式声明。</p>
<h3 id="412-类型安全"><a class="header" href="#412-类型安全">4.1.2 类型安全</a></h3>
<p><strong>C语言的类型安全问题：</strong></p>
<pre><code class="language-c">int main() {
    int a = 10;
    float b = 3.14;
    int result = a + b;  // 隐式类型转换，可能丢失精度
    return 0;
}
</code></pre>
<p><strong>Rust的类型安全：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: i32 = 10;
    let b: f64 = 3.14;
    // let result = a + b;  // 编译错误：不能直接相加不同类型
    
    // 正确的做法
    let result = a as f64 + b;  // 显式类型转换
    println!("结果: {}", result);
}</code></pre></pre>
<p>Rust禁止隐式类型转换，要求开发者明确表达意图。这看起来可能有些麻烦，但实际上避免了意外的精度丢失和类型错误。当我们确实需要类型转换时，必须使用 <code>as</code> 关键字显式转换，这样代码的意图就非常清楚了。</p>
<h2 id="42-内存管理对比"><a class="header" href="#42-内存管理对比">4.2 内存管理对比</a></h2>
<h3 id="421-手动管理-vs-自动管理"><a class="header" href="#421-手动管理-vs-自动管理">4.2.1 手动管理 vs 自动管理</a></h3>
<p><strong>C语言的手动内存管理：</strong></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    // 手动分配内存
    int* ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL) {
        return 1;  // 检查分配失败
    }
    
    *ptr = 42;
    printf("值: %d\n", *ptr);
    
    // 手动释放内存
    free(ptr);
    ptr = NULL;  // 避免悬垂指针
    
    return 0;
}
</code></pre>
<p><strong>Rust的自动内存管理：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 自动分配和释放内存
    let value = Box::new(42);
    println!("值: {}", value);
    
    // 离开作用域时自动释放
} // 这里 value 自动释放</code></pre></pre>
<p>C语言需要手动管理内存的分配和释放。当我们使用 <code>malloc</code> 分配内存时，必须记住用 <code>free</code> 释放，否则会造成内存泄漏。Rust通过所有权机制自动管理内存，当变量离开作用域时，内存会自动释放，不需要手动管理。</p>
<h3 id="422-所有权机制"><a class="header" href="#422-所有权机制">4.2.2 所有权机制</a></h3>
<p><strong>C语言的指针问题：</strong></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int* create_value() {
    int* ptr = (int*)malloc(sizeof(int));
    *ptr = 42;
    return ptr;  // 返回指针，调用者负责释放
}

void use_value(int* ptr) {
    printf("值: %d\n", *ptr);
    // 这里不能释放，因为不知道是否还有其他地方在使用
}

int main() {
    int* ptr = create_value();
    use_value(ptr);
    free(ptr);  // 容易忘记释放
    return 0;
}
</code></pre>
<p><strong>Rust的所有权机制：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn create_value() -&gt; Box&lt;i32&gt; {
    Box::new(42)  // 返回所有权
}

fn use_value(value: Box&lt;i32&gt;) {
    println!("值: {}", value);
} // value 在这里被释放

fn main() {
    let value = create_value();
    use_value(value);  // 所有权转移给 use_value
    // println!("{}", value);  // 编译错误：value 已经被移动
}</code></pre></pre>
<p>在C语言中，当我们返回一个指针时，调用者需要负责释放内存。这容易造成内存泄漏或重复释放的问题。Rust的所有权机制确保每个值只有一个所有者，当所有权转移时，原来的变量就不能再使用了。这避免了内存管理的问题。</p>
<h3 id="423-借用机制"><a class="header" href="#423-借用机制">4.2.3 借用机制</a></h3>
<p><strong>C语言的引用传递：</strong></p>
<pre><code class="language-c">void modify_value(int* ptr) {
    *ptr = 100;  // 直接修改原值
}

int main() {
    int value = 42;
    modify_value(&amp;value);
    printf("修改后: %d\n", value);  // 输出: 100
    return 0;
}
</code></pre>
<p><strong>Rust的借用机制：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn modify_value(value: &amp;mut i32) {
    *value = 100;  // 通过可变引用修改
}

fn main() {
    let mut value = 42;
    modify_value(&amp;mut value);
    println!("修改后: {}", value);  // 输出: 100
}</code></pre></pre>
<p><strong>不可变借用：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn print_value(value: &amp;i32) {
    println!("值: {}", value);
}

fn main() {
    let value = 42;
    print_value(&amp;value);  // 不可变借用
    println!("原值: {}", value);  // 仍然可以使用
}</code></pre></pre>
<p>Rust的借用机制比C语言的指针更安全。当我们使用引用时，编译器会检查引用的生命周期，确保引用不会指向已经释放的内存。同时，Rust区分了可变引用和不可变引用，防止了数据竞争。</p>
<h2 id="43-错误处理对比"><a class="header" href="#43-错误处理对比">4.3 错误处理对比</a></h2>
<h3 id="431-c语言的错误处理"><a class="header" href="#431-c语言的错误处理">4.3.1 C语言的错误处理</a></h3>
<p><strong>C语言的传统错误处理：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int divide(int a, int b) {
    if (b == 0) {
        return -1;  // 错误码
    }
    return a / b;
}

int main() {
    int result = divide(10, 0);
    if (result == -1) {
        printf("错误：除数不能为零\n");
        return 1;
    }
    printf("结果: %d\n", result);
    return 0;
}
</code></pre>
<h3 id="432-rust的result类型"><a class="header" href="#432-rust的result类型">4.3.2 Rust的Result类型</a></h3>
<p><strong>Rust的Result错误处理：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        Err("除数不能为零")
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 0) {
        Ok(result) =&gt; println!("结果: {}", result),
        Err(error) =&gt; println!("错误: {}", error),
    }
}</code></pre></pre>
<p><strong>使用?运算符简化错误处理：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        return Err("除数不能为零");
    }
    Ok(a / b)
}

fn process_division() -&gt; Result&lt;(), &amp;'static str&gt; {
    let result = divide(10, 2)?;  // 如果出错，直接返回错误
    println!("结果: {}", result);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>C语言使用特殊的返回值（如-1）来表示错误，这种方法简单但容易忘记检查。Rust的Result类型明确区分了成功和失败的情况，程序必须处理这两种情况，不能忽略错误。</p>
<h3 id="433-option类型"><a class="header" href="#433-option类型">4.3.3 Option类型</a></h3>
<p><strong>C语言处理空值：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int* find_value(int* arr, int size, int target) {
    for (int i = 0; i &lt; size; i++) {
        if (arr[i] == target) {
            return &amp;arr[i];  // 返回指针，可能为NULL
        }
    }
    return NULL;  // 表示未找到
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int* result = find_value(arr, 5, 3);
    
    if (result != NULL) {
        printf("找到值: %d\n", *result);
    } else {
        printf("未找到值\n");
    }
    return 0;
}
</code></pre>
<p><strong>Rust的Option类型：</strong></p>
<pre><pre class="playground"><code class="language-rust">fn find_value(arr: &amp;[i32], target: i32) -&gt; Option&lt;&amp;i32&gt; {
    for item in arr {
        if *item == target {
            return Some(item);
        }
    }
    None
}

fn main() {
    let arr = [1, 2, 3, 4, 5];
    match find_value(&amp;arr, 3) {
        Some(value) =&gt; println!("找到值: {}", value),
        None =&gt; println!("未找到值"),
    }
}</code></pre></pre>
<p>Option类型就像是一个安全的盒子，如果我们遇到有可能为空的时候，必须要用这个盒子装起来。如果我们想要拿到盒子里面的值，就必须要告诉编译器如何处理空值的情况。</p>
<p>上面的例子中，通过match匹配，如果是空值那么就输出未找到值。所以我们可以看到，Rust中，可能的空值都会被我们手动处理。即使在取出这个值的时候程序终止，也一定是我们要求的，不会出现C语言莫名其妙的崩溃！</p>
<h2 id="44-并发安全对比"><a class="header" href="#44-并发安全对比">4.4 并发安全对比</a></h2>
<h3 id="441-c语言的多线程问题"><a class="header" href="#441-c语言的多线程问题">4.4.1 C语言的多线程问题</a></h3>
<p><strong>C语言的数据竞争：</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int counter = 0;  // 全局变量

void* increment(void* arg) {
    for (int i = 0; i &lt; 10000; i++) {
        counter++;  // 数据竞争！
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    pthread_create(&amp;thread1, NULL, increment, NULL);
    pthread_create(&amp;thread2, NULL, increment, NULL);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("最终计数: %d\n", counter);  // 结果不确定
    return 0;
}
</code></pre>
<h3 id="442-rust的并发安全"><a class="header" href="#442-rust的并发安全">4.4.2 Rust的并发安全</a></h3>
<p><strong>Rust的线程安全：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..2 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..10000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", *counter.lock().unwrap());
}</code></pre></pre>
<p><strong>Rust的Send和Sync trait：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // 移动所有权到新线程
    let handle = thread::spawn(move || {
        println!("在新线程中处理数据: {:?}", data);
    });
    
    handle.join().unwrap();
}</code></pre></pre>
<p>C语言中，多个线程可以同时访问同一个变量，这可能导致数据竞争。程序员需要手动使用锁来保护共享数据。Rust通过类型系统在编译时检查并发安全问题，如果一个数据可能被多个线程访问，必须使用特殊的类型来确保安全。</p>
<h2 id="45-零成本抽象"><a class="header" href="#45-零成本抽象">4.5 零成本抽象</a></h2>
<h3 id="451-什么是零成本抽象"><a class="header" href="#451-什么是零成本抽象">4.5.1 什么是零成本抽象？</a></h3>
<p>零成本抽象是Rust的核心设计理念之一，它的含义是：<strong>高级抽象不应该带来运行时性能损失</strong>。换句话说，你写的抽象代码在编译后应该和手写的低级代码性能相同。</p>
<p><strong>抽象的概念：</strong>
抽象就像是把复杂的事情简化。比如，当我们说"开车"时，我们不需要知道发动机如何工作、变速箱如何换挡，我们只需要踩油门、踩刹车、转方向盘。这就是抽象——隐藏复杂的细节，提供简单的接口。</p>
<p><strong>零成本的含义：</strong>
零成本意味着使用抽象不会让你付出性能代价。就像开车一样，你不需要因为使用了"开车"这个抽象概念而开得更慢。在编程中，使用迭代器、泛型、trait等高级抽象，不应该比手写循环、具体类型、函数指针更慢。</p>
<h3 id="452-为什么零成本抽象如此重要"><a class="header" href="#452-为什么零成本抽象如此重要">4.5.2 为什么零成本抽象如此重要？</a></h3>
<p><strong>性能与安全性的平衡：</strong>
在传统编程中，我们经常面临一个选择：要么写高性能但危险的代码，要么写安全但慢的代码。比如C语言可以写出非常快的代码，但容易出现内存错误；Java提供了安全的抽象，但垃圾回收会带来性能损失。</p>
<p>Rust的零成本抽象打破了这种权衡。你可以同时拥有：</p>
<ul>
<li>高级抽象的安全性</li>
<li>低级代码的性能</li>
<li>编译时的错误检查</li>
</ul>
<p><strong>实际开发中的意义：</strong>
想象一下，如果你是一个游戏开发者。你需要处理大量的游戏对象Object，每个对象都有位置、速度、生命值等属性。你希望代码既安全又高效：
避免数组越界、空指针等错误。每秒处理60帧，每帧处理数千个对象。代码要容易理解和维护</p>
<p>零成本抽象让你可以写出既安全又高效的代码，而不需要在这两者之间妥协。</p>
<h3 id="453-c和c的问题"><a class="header" href="#453-c和c的问题">4.5.3 C和C++的问题</a></h3>
<p><strong>C语言的问题：</strong></p>
<p>C语言几乎没有抽象机制，所有事情都要手动处理：</p>
<pre><code class="language-c">// C语言：手动管理数组
int arr[] = {1, 2, 3, 4, 5};
int sum = 0;
for (int i = 0; i &lt; 5; i++) {
    sum += arr[i];  // 容易越界
}

// 如果要安全，需要额外的检查
int sum_safe(int* arr, int size) {
    int sum = 0;
    for (int i = 0; i &lt; size; i++) {
        if (i &lt; size) {  // 冗余检查
            sum += arr[i];
        }
    }
    return sum;
}
</code></pre>
<p><strong>C++的问题：</strong></p>
<p>C++提供了抽象，但经常带来性能损失：</p>
<pre><code class="language-cpp">// C++：使用STL容器
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int sum = 0;
for (auto it = vec.begin(); it != vec.end(); ++it) {
    sum += *it;  // 迭代器可能比直接索引慢
}

// 或者使用范围for循环
int sum2 = 0;
for (const auto&amp; item : vec) {
    sum2 += item;  // 可能有额外的开销
}
</code></pre>
<p><strong>C++抽象的成本：</strong></p>
<ol>
<li><strong>虚函数调用</strong>：虚函数需要查表，比直接函数调用慢</li>
<li><strong>模板实例化</strong>：每个类型都会生成不同的代码，增加编译时间和二进制大小</li>
<li><strong>异常处理</strong>：异常机制需要额外的运行时支持</li>
<li><strong>RAII开销</strong>：构造函数和析构函数可能带来不必要的开销</li>
</ol>
<h3 id="454-rust的零成本抽象实现"><a class="header" href="#454-rust的零成本抽象实现">4.5.4 Rust的零成本抽象实现</a></h3>
<p><strong>迭代器对比：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust：使用迭代器
fn sum_with_iterator(arr: &amp;[i32]) -&gt; i32 {
    arr.iter().sum()  // 高级抽象
}

// 手写循环
fn sum_with_loop(arr: &amp;[i32]) -&gt; i32 {
    let mut sum = 0;
    for &amp;item in arr {
        sum += item;
    }
    sum
}

// 编译后，这两种方法的性能几乎相同。
// rustc可以把性能优化到跟C语言几乎相同的性能
<span class="boring">}</span></code></pre></pre>
<p><strong>泛型对比：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust：泛型函数
fn max&lt;T: PartialOrd&gt;(a: T, b: T) -&gt; T {
    if a &gt; b { a } else { b }
}

// 使用泛型
let max_int = max(10, 20);
let max_float = max(3.14, 2.71);

// 编译时，Rust会为每个具体类型生成专门的代码
// 就像手写了两个不同的函数一样
<span class="boring">}</span></code></pre></pre>
<p><strong>Trait对象：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust：trait对象（动态分发）
trait Drawable {
    fn draw(&amp;self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&amp;self) { /* 画圆 */ }
}

impl Drawable for Square {
    fn draw(&amp;self) { /* 画方 */ }
}

// 使用trait对象
fn draw_all(shapes: &amp;[Box&lt;dyn Drawable&gt;]) {
    for shape in shapes {
        shape.draw();  // 动态分发，但开销很小
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="455-零成本抽象的技术原理"><a class="header" href="#455-零成本抽象的技术原理">4.5.5 零成本抽象的技术原理</a></h3>
<p><strong>编译时优化：</strong>
Rust编译器非常智能，能够：</p>
<ul>
<li>内联函数调用</li>
<li>消除死代码</li>
<li>优化内存布局</li>
<li>进行常量折叠</li>
</ul>
<p><strong>单态化（Monomorphization）：</strong>
对于泛型代码，Rust会为每个具体类型生成专门的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 泛型函数
fn process&lt;T&gt;(data: T) -&gt; T {
    // 处理逻辑
}

// 编译器会生成：
fn process_i32(data: i32) -&gt; i32 { /* 专门处理i32的代码 */ }
fn process_string(data: String) -&gt; String { /* 专门处理String的代码 */ }
<span class="boring">}</span></code></pre></pre>
<p><strong>所有权系统的优化：</strong>
Rust的所有权系统在编译时就能确定内存布局，避免了运行时的开销：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 编译时就知道内存布局
struct Point {
    x: f64,
    y: f64,
}

// 编译器可以优化内存访问模式
let points = vec![Point { x: 1.0, y: 2.0 }];
<span class="boring">}</span></code></pre></pre>
<h3 id="456-实际性能对比"><a class="header" href="#456-实际性能对比">4.5.6 实际性能对比</a></h3>
<p><strong>内存安全 vs 性能：</strong></p>
<pre><code class="language-c">// C语言：快速但不安全
int* create_array(int size) {
    return malloc(size * sizeof(int));  // 可能失败
}

void use_array(int* arr, int size) {
    for (int i = 0; i &lt;= size; i++) {  // 越界！
        arr[i] = i;
    }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust：安全且高效
fn create_array(size: usize) -&gt; Vec&lt;i32&gt; {
    vec![0; size]  // 自动处理内存分配
}

fn use_array(arr: &amp;mut [i32]) {
    for (i, item) in arr.iter_mut().enumerate() {
        *item = i as i32;  // 不可能越界
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>编译后性能：</strong>
Rust的代码在编译后通常与手写的C代码性能相同，但提供了内存安全保证。</p>
<h2 id="46-包管理和模块系统"><a class="header" href="#46-包管理和模块系统">4.6 包管理和模块系统</a></h2>
<h3 id="461-c语言的模块管理"><a class="header" href="#461-c语言的模块管理">4.6.1 C语言的模块管理</a></h3>
<p><strong>C语言的头文件和源文件：</strong></p>
<pre><code class="language-c">// math.h
#ifndef MATH_H
#define MATH_H

int add(int a, int b);
int multiply(int a, int b);

#endif

// math.c
#include "math.h"

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

// main.c
#include &lt;stdio.h&gt;
#include "math.h"

int main() {
    int result1 = add(5, 3);
    int result2 = multiply(4, 6);
    printf("5 + 3 = %d\n", result1);
    printf("4 * 6 = %d\n", result2);
    return 0;
}
</code></pre>
<h3 id="462-rust的模块系统"><a class="header" href="#462-rust的模块系统">4.6.2 Rust的模块系统</a></h3>
<p><strong>Rust的模块组织：</strong></p>
<pre><pre class="playground"><code class="language-rust">// lib.rs 或 main.rs
mod math {
    pub fn add(a: i32, b: i32) -&gt; i32 {
        a + b
    }
    
    pub fn multiply(a: i32, b: i32) -&gt; i32 {
        a * b
    }
}

fn main() {
    let result1 = math::add(5, 3);
    let result2 = math::multiply(4, 6);
    println!("5 + 3 = {}", result1);
    println!("4 * 6 = {}", result2);
}</code></pre></pre>
<p><strong>使用外部依赖：</strong></p>
<pre><pre class="playground"><code class="language-rust">// Cargo.toml
// [dependencies]
// serde = "1.0"
// serde_json = "1.0"

use serde::{Deserialize, Serialize};
use serde_json;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person = Person {
        name: "张三".to_string(),
        age: 25,
    };
    
    let json = serde_json::to_string(&amp;person).unwrap();
    println!("JSON: {}", json);
}</code></pre></pre>
<p>C语言使用头文件来声明函数和变量，这种方式简单但容易出现重复包含和依赖管理问题。Rust的模块系统更加现代化，提供了更好的封装和依赖管理。Cargo作为包管理器，自动处理依赖关系，大大简化了项目的构建过程。</p>
<h2 id="47-总结对比"><a class="header" href="#47-总结对比">4.7 总结对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>C语言</th><th>Rust</th></tr></thead><tbody>
<tr><td>类型系统</td><td>静态类型，需显式声明</td><td>静态类型，支持类型推断</td></tr>
<tr><td>内存管理</td><td>手动管理</td><td>所有权机制自动管理</td></tr>
<tr><td>错误处理</td><td>返回码/异常</td><td>Result/Option类型</td></tr>
<tr><td>并发安全</td><td>需手动保证</td><td>编译期检查</td></tr>
<tr><td>抽象能力</td><td>宏/函数指针</td><td>泛型/Trait</td></tr>
<tr><td>包管理</td><td>手动管理</td><td>Cargo统一管理</td></tr>
<tr><td>编译速度</td><td>快</td><td>较慢（安全检查）</td></tr>
<tr><td>运行时性能</td><td>高</td><td>高（零成本抽象）</td></tr>
<tr><td>安全性</td><td>低（需开发者保证）</td><td>高（编译期保证）</td></tr>
</tbody></table>
</div>
<h2 id="48-思考题"><a class="header" href="#48-思考题">4.8 思考题</a></h2>
<ol>
<li>Rust的所有权机制如何解决C语言中的内存泄漏问题？</li>
<li>为什么Rust的编译时间比C语言长？这种权衡值得吗？</li>
<li>Rust的Result类型相比C语言的错误码有什么优势？</li>
<li>试比较C语言的指针和Rust的引用在安全性方面的差异。</li>
<li>Rust的零成本抽象是如何实现的？请举例说明。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版权声明"><a class="header" href="#版权声明">版权声明</a></h1>
<p>《New for Rust》教程及其配套资料，版权归作者及项目团队所有。</p>
<p>本教程面向有一点C语言基础但对Rust不熟悉的开发者，旨在推广Rust语言的学习与工程实践，支持企业内部培训和个人自学。除非特别说明，教程内容采用以下授权方式：</p>
<ul>
<li><strong>个人学习与非商业用途</strong>：允许自由阅读、下载、引用和分享本教程内容，但请注明出处。</li>
<li><strong>企业内部培训</strong>：欢迎企业在内部培训、学习小组等场景中使用本教程内容，无需额外授权，但请勿对内容进行大规模修改后以自有名义发布。</li>
<li><strong>开源社区交流</strong>：欢迎在开源社区、技术论坛等非商业场合分享、讨论本教程内容，鼓励二次创作和经验交流，但请保留原作者信息。</li>
<li><strong>禁止商业出版与盈利性传播</strong>：未经作者或项目团队书面许可，禁止将本教程内容用于商业出版、付费课程、盈利性传播等用途。</li>
</ul>
<p>本教程部分内容参考了Rust官方文档、开源社区资料及相关技术书籍，均已注明出处。如有版权疑问或合作需求，请联系作者或项目团队。</p>
<p><strong>版权所有 © 2024 New for Rust 项目组 保留所有权利</strong></p>
<p>喜欢的话可以请我喝杯奶茶</p>
<p align = "center">
<img src="assets/qrcode.png" alt="支付宝" width="300" />
</p>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
